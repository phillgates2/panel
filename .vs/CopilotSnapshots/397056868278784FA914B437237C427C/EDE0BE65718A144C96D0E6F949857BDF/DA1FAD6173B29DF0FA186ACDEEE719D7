"""Database models for the Panel application."""
import json
from datetime import datetime, timezone, timedelta
from typing import Optional, List

from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import check_password_hash, generate_password_hash

db = SQLAlchemy()


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    first_name = db.Column(db.String(80), nullable=False)
    last_name = db.Column(db.String(80), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    dob = db.Column(db.Date, nullable=False)
    password_hash = db.Column(db.String(256), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    reset_token = db.Column(db.String(128), nullable=True)
    role = db.Column(db.String(32), default="user")

    # Two-Factor Authentication
    totp_secret = db.Column(db.String(32), nullable=True)  # TOTP secret for 2FA
    totp_enabled = db.Column(db.Boolean, default=False)  # Whether 2FA is enabled
    backup_codes = db.Column(db.Text, nullable=True)  # JSON array of backup codes

    # API Access
    api_token = db.Column(db.String(128), nullable=True, unique=True)  # API access token
    api_token_created = db.Column(db.DateTime, nullable=True)  # When token was created
    api_token_last_used = db.Column(db.DateTime, nullable=True)  # Last API usage

    # Session management
    last_login = db.Column(db.DateTime, nullable=True)
    login_attempts = db.Column(db.Integer, default=0)
    locked_until = db.Column(db.DateTime, nullable=True)

    # Profile
    bio = db.Column(db.Text, nullable=True)  # User biography
    avatar = db.Column(db.String(255), nullable=True)  # Avatar image filename

    def set_password(self, password: str) -> None:
        """Set the user's password."""
        self.password_hash = generate_password_hash(password)

    def check_password(self, password: str) -> bool:
        """Check the user's password."""
        return check_password_hash(self.password_hash, password)

    def is_account_locked(self) -> bool:
        """Check if account is temporarily locked due to failed login attempts."""
        if self.locked_until and datetime.now(timezone.utc) < self.locked_until:
            return True
        return False

    def record_login_attempt(self, success: bool = False) -> None:
        """Record a login attempt and handle account locking."""
        if success:
            self.login_attempts = 0
            self.locked_until = None
            self.last_login = datetime.now(timezone.utc)
        else:
            self.login_attempts += 1
            if self.login_attempts >= 5:  # Lock after 5 failed attempts
                self.locked_until = datetime.now(timezone.utc) + timedelta(minutes=15)

    def verify_totp(self, code: str) -> bool:
        """Verify TOTP code for 2FA."""
        if not self.totp_enabled or not self.totp_secret:
            return True  # 2FA not enabled

        try:
            import pyotp

            totp = pyotp.TOTP(self.totp_secret)
            return totp.verify(code)
        except Exception:
            return False

    def generate_backup_codes(self) -> List[str]:
        """Generate new backup codes for account recovery."""
        import secrets

        codes = [secrets.token_hex(4).upper() for _ in range(10)]
        self.backup_codes = json.dumps(codes)
        return codes

    def use_backup_code(self, code: str) -> bool:
        """Use a backup code and remove it from the list."""
        if not self.backup_codes:
            return False

        try:
            codes = json.loads(self.backup_codes)
            if code in codes:
                codes.remove(code)
                self.backup_codes = json.dumps(codes) if codes else None
                return True
        except Exception:
            pass
        return False

    @property
    def display_name(self) -> str:
        """Return full name or email as display name"""
        if self.first_name and self.last_name:
            return f"{self.first_name} {self.last_name}"
        return self.email

    def is_system_admin(self) -> bool:
        return (self.role == "system_admin") or (
            self.email.lower() in getattr(config, "ADMIN_EMAILS", [])
        )

    def is_server_admin(self) -> bool:
        return self.role == "server_admin"

    def is_server_mod(self) -> bool:
        return self.role == "server_mod"

    def generate_api_token(self) -> str:
        """Generate a new API token for the user."""
        import secrets

        self.api_token = secrets.token_urlsafe(64)
        self.api_token_created = datetime.now(timezone.utc)
        return self.api_token

    def revoke_api_token(self) -> None:
        """Revoke the current API token."""
        self.api_token = None
        self.api_token_created = None
        self.api_token_last_used = None

    def validate_api_token(self, token: str) -> bool:
        """Validate an API token and update last used time."""
        if self.api_token and self.api_token == token:
            self.api_token_last_used = datetime.now(timezone.utc)
            return True
        return False


# Association table: server-specific roles for users (server_admin/server_mod)
class ServerUser(db.Model):
    __tablename__ = "server_user"
    id = db.Column(db.Integer, primary_key=True)
    server_id = db.Column(db.Integer, db.ForeignKey("server.id"), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    role = db.Column(db.String(32), nullable=False)  # 'server_admin' or 'server_mod'
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))


class Server(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), unique=True, nullable=False)
    description = db.Column(db.String(512), nullable=True)
    host = db.Column(db.String(128), nullable=True)  # server host/IP
    port = db.Column(db.Integer, nullable=True)  # server port
    rcon_password = db.Column(db.String(128), nullable=True)  # RCON password
    variables_json = db.Column(db.Text, nullable=True)  # structured variables (JSON)
    raw_config = db.Column(db.Text, nullable=True)  # raw server config
    game_type = db.Column(
        db.String(32), default="etlegacy", nullable=False
    )  # game type for configs
    owner_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)  # server owner
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc),
    )
    users = db.relationship("ServerUser", backref="server", cascade="all, delete-orphan")
    owner = db.relationship("User", foreign_keys=[owner_id])


class AuditLog(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    actor_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)
    action = db.Column(db.String(1024), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))


class SiteSetting(db.Model):
    """Simple key/value storage for site-wide settings.

    Keys used:
        - 'custom_theme_css' : text containing CSS
        - 'theme_enabled' : '1' or '0'
    """

    id = db.Column(db.Integer, primary_key=True)
    key = db.Column(db.String(128), unique=True, nullable=False)
    value = db.Column(db.Text, nullable=True)


class SiteAsset(db.Model):
    """Store uploaded theme assets (logos) in DB when configured.

    Fields:
        - filename: sanitized filename used in URL
        - data: binary blob
        - mimetype: original/derived mimetype
        - created_at
    """

    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(256), unique=True, nullable=False)
    data = db.Column(db.LargeBinary, nullable=False)
    mimetype = db.Column(db.String(128), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))


class IPWhitelist(db.Model):
    """IP addresses allowed to access the system."""

    __tablename__ = "ip_whitelist"

    id = db.Column(db.Integer, primary_key=True)
    ip_address = db.Column(db.String(45), nullable=False, unique=True)  # IPv4/IPv6 support
    description = db.Column(db.String(256), nullable=True)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    created_by = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)

    creator = db.relationship("User")


class IPBlacklist(db.Model):
    """IP addresses blocked from accessing the system."""

    __tablename__ = "ip_blacklist"

    id = db.Column(db.Integer, primary_key=True)
    ip_address = db.Column(db.String(45), nullable=False, unique=True)  # IPv4/IPv6 support
    reason = db.Column(db.String(256), nullable=True)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    created_by = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)

    creator = db.relationship("User")


class SecurityEvent(db.Model):
    """Log security-related events."""

    __tablename__ = "security_event"

    id = db.Column(db.Integer, primary_key=True)
    event_type = db.Column(db.String(64), nullable=False)  # login_attempt, ip_blocked, etc.
    ip_address = db.Column(db.String(45), nullable=True)
    user_agent = db.Column(db.Text, nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)
    description = db.Column(db.Text, nullable=True)
    severity = db.Column(db.String(16), default="info")  # info, warning, critical
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

    user = db.relationship("User")