"""
Database Optimization and Profiling
Provides query profiling, index recommendations, and performance monitoring
"""

import time
import logging
from typing import Dict, List, Any, Optional
from contextlib import contextmanager
from sqlalchemy import event, text
from sqlalchemy.engine import Engine
from flask import Flask, g

logger = logging.getLogger(__name__)


class QueryProfiler:
    """Database query profiling and optimization recommendations"""

    def __init__(self, app: Optional[Flask] = None, slow_query_threshold: float = 0.1):
        self.app = app
        self.slow_query_threshold = slow_query_threshold
        self.query_stats: Dict[str, Dict[str, Any]] = {}
        self.enabled = True

    def init_app(self, app: Flask) -> None:
        """Initialize query profiling for Flask app"""
        self.app = app

        # SQLAlchemy event listeners
        from src.panel import db

        @event.listens_for(db.engine, "before_cursor_execute")
        def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
            if self.enabled:
                g.query_start_time = time.time()
                g.query_statement = statement

        @event.listens_for(db.engine, "after_cursor_execute")
        def after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
            if self.enabled and hasattr(g, 'query_start_time'):
                duration = time.time() - g.query_start_time
                self.record_query(statement, duration)

                # Log slow queries
                if duration > self.slow_query_threshold:
                    logger.warning(
                        "Slow query detected",
                        extra={
                            "query": statement[:500] + "..." if len(statement) > 500 else statement,
                            "duration": duration,
                            "slow_threshold": self.slow_query_threshold
                        }
                    )

    def record_query(self, statement: str, duration: float) -> None:
        """Record query execution statistics"""
        # Extract table name from query (simple heuristic)
        table_name = self.extract_table_name(statement)

        if table_name not in self.query_stats:
            self.query_stats[table_name] = {
                'count': 0,
                'total_time': 0.0,
                'avg_time': 0.0,
                'max_time': 0.0,
                'queries': []
            }

        stats = self.query_stats[table_name]
        stats['count'] += 1
        stats['total_time'] += duration
        stats['avg_time'] = stats['total_time'] / stats['count']
        stats['max_time'] = max(stats['max_time'], duration)

        # Keep sample of recent queries
        if len(stats['queries']) < 10:
            stats['queries'].append({
                'statement': statement[:200] + "..." if len(statement) > 200 else statement,
                'duration': duration,
                'timestamp': time.time()
            })

    def extract_table_name(self, statement: str) -> str:
        """Extract table name from SQL statement"""
        import re

        # Common patterns for table names in SQL
        patterns = [
            r'FROM\s+(\w+)',
            r'UPDATE\s+(\w+)',
            r'INSERT\s+INTO\s+(\w+)',
            r'DELETE\s+FROM\s+(\w+)',
            r'ALTER\s+TABLE\s+(\w+)',
            r'CREATE\s+TABLE\s+(\w+)'
        ]

        for pattern in patterns:
            match = re.search(pattern, statement, re.IGNORECASE)
            if match:
                return match.group(1).lower()

        return 'unknown'

    def get_query_stats(self) -> Dict[str, Dict[str, Any]]:
        """Get current query statistics"""
        return self.query_stats.copy()

    def get_index_recommendations(self) -> List[Dict[str, Any]]:
        """Generate index recommendations based on query patterns"""
        recommendations = []

        for table_name, stats in self.query_stats.items():
            if table_name == 'unknown':
                continue

            # Analyze queries for potential indexes
            for query_info in stats['queries']:
                statement = query_info['statement'].upper()

                # Look for WHERE clauses that might benefit from indexes
                if 'WHERE' in statement:
                    # Simple heuristic: recommend indexes on columns used in WHERE
                    # In a real implementation, this would use query parsing
                    if 'USER_ID' in statement and table_name != 'user':
                        recommendations.append({
                            'table': table_name,
                            'column': 'user_id',
                            'reason': 'Frequently queried by user_id',
                            'estimated_impact': 'high'
                        })

                    if 'EMAIL' in statement:
                        recommendations.append({
                            'table': table_name,
                            'column': 'email',
                            'reason': 'Email lookups are common',
                            'estimated_impact': 'medium'
                        })

                    if 'CREATED_AT' in statement and 'ORDER BY' in statement:
                        recommendations.append({
                            'table': table_name,
                            'column': 'created_at',
                            'reason': 'Time-based ordering queries',
                            'estimated_impact': 'medium'
                        })

        # Remove duplicates
        seen = set()
        unique_recommendations = []
        for rec in recommendations:
            key = (rec['table'], rec['column'])
            if key not in seen:
                seen.add(key)
                unique_recommendations.append(rec)

        return unique_recommendations

    def get_performance_report(self) -> Dict[str, Any]:
        """Generate a comprehensive performance report"""
        return {
            'query_stats': self.get_query_stats(),
            'index_recommendations': self.get_index_recommendations(),
            'slow_queries': [
                {
                    'table': table,
                    'count': stats['count'],
                    'avg_time': stats['avg_time'],
                    'max_time': stats['max_time']
                }
                for table, stats in self.query_stats.items()
                if stats['avg_time'] > self.slow_query_threshold
            ],
            'total_queries': sum(stats['count'] for stats in self.query_stats.values()),
            'profiling_enabled': self.enabled
        }


# Global profiler instance
query_profiler = QueryProfiler()


def get_query_profiler() -> QueryProfiler:
    """Get the global query profiler instance"""
    return query_profiler


def init_db_optimization(app: Flask) -> None:
    """Initialize database optimization and profiling"""
    query_profiler.init_app(app)
    app.logger.info("Database optimization and profiling initialized")


# Database index recommendations based on common query patterns
INDEX_RECOMMENDATIONS = [
    {
        'table': 'user',
        'columns': ['email'],
        'type': 'unique',
        'reason': 'Email uniqueness and login lookups'
    },
    {
        'table': 'user',
        'columns': ['last_login'],
        'type': 'btree',
        'reason': 'Active user queries and session management'
    },
    {
        'table': 'server',
        'columns': ['owner_id'],
        'type': 'btree',
        'reason': 'Server ownership queries'
    },
    {
        'table': 'server_user',
        'columns': ['server_id', 'user_id'],
        'type': 'unique',
        'reason': 'Server-user relationship lookups'
    },
    {
        'table': 'audit_log',
        'columns': ['created_at'],
        'type': 'btree',
        'reason': 'Time-based audit log queries'
    },
    {
        'table': 'site_setting',
        'columns': ['key'],
        'type': 'unique',
        'reason': 'Setting key lookups'
    }
]


def get_index_recommendations() -> List[Dict[str, Any]]:
    """Get recommended database indexes"""
    return INDEX_RECOMMENDATIONS.copy()


def generate_index_sql() -> List[str]:
    """Generate SQL statements for recommended indexes"""
    sql_statements = []

    for rec in INDEX_RECOMMENDATIONS:
        table = rec['table']
        columns = rec['columns']
        index_type = rec.get('type', 'btree')

        if len(columns) == 1:
            index_name = f"idx_{table}_{columns[0]}"
            if index_type == 'unique':
                sql = f"CREATE UNIQUE INDEX IF NOT EXISTS {index_name} ON {table} ({columns[0]});"
            else:
                sql = f"CREATE INDEX IF NOT EXISTS {index_name} ON {table} ({columns[0]});"
        else:
            index_name = f"idx_{table}_{'_'.join(columns)}"
            cols_str = ', '.join(columns)
            if index_type == 'unique':
                sql = f"CREATE UNIQUE INDEX IF NOT EXISTS {index_name} ON {table} ({cols_str});"
            else:
                sql = f"CREATE INDEX IF NOT EXISTS {index_name} ON {table} ({cols_str});"

        sql_statements.append(sql)

    return sql_statements