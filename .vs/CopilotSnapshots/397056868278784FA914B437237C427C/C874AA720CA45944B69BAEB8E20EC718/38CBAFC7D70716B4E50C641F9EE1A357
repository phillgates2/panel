import csv
import io
import os
import secrets
import shutil
import time
from datetime import date, datetime, timedelta, timezone
from pathlib import Path

from flask import (
    Blueprint,
    Flask,
    Response,
    abort,
    flash,
    jsonify,
    redirect,
    render_template,
    render_template_string,
    request,
    send_file,
    session,
    url_for,
)
from flask_caching import Cache
from flask_compress import Compress
from flask_socketio import SocketIO, emit, join_room, leave_room
from flask_sqlalchemy import SQLAlchemy
from werkzeug.datastructures import FileStorage
from werkzeug.utils import secure_filename

# Unbound SQLAlchemy instance; `db.init_app(app)` will be called for each app.
# db = SQLAlchemy()
# Some Werkzeug builds used in minimal containers may not expose a __version__ attribute
import werkzeug
from sqlalchemy import text
from werkzeug.security import check_password_hash, generate_password_hash

try:
    import importlib.metadata

    werkzeug_version = importlib.metadata.version("werkzeug")
    werkzeug.__version__ = werkzeug_version
except Exception:
    # Fallback for older Python versions or if metadata is unavailable
    werkzeug.__version__ = getattr(werkzeug, "__release__", "0")

# Load environment variables from .env file
from dotenv import load_dotenv

load_dotenv()

import json  # noqa: E402
import subprocess  # noqa: E402

import redis  # noqa: E402
from PIL import Image, ImageOps  # noqa: E402
from rq import Queue  # noqa: E402

# The following imports are intentionally placed after loading environment
# variables. Ruff/flake8 may flag E402 (imports not at module top); silence
# that rule here because we need env vars loaded before `config`.
import config  # noqa: E402
import tasks  # noqa: E402
from captcha import generate_captcha_audio, generate_captcha_image  # noqa: E402
from database_admin import DATABASE_ADMIN_BASE_TEMPLATE  # noqa: E402
from database_admin import (
    DATABASE_ADMIN_HOME_TEMPLATE,
    DATABASE_ADMIN_QUERY_TEMPLATE,
    DATABASE_ADMIN_TABLE_TEMPLATE,
    DatabaseAdmin,
)

# Import models and utilities
# from models_extended import RconCommandHistory  # noqa: E402
# from monitoring_system import ServerMetrics  # noqa: E402
# from rbac import has_permission  # noqa: E402
from rcon_client import ETLegacyRcon  # noqa: E402
from validate_config import ConfigValidator  # noqa: E402

# Import input validation schemas
from input_validation import LoginSchema, RegisterSchema, validate_request  # noqa: E402

# Import services
from services import get_cache_service  # noqa: E402

import models  # noqa: E402

"""
CODE STRUCTURE NOTES:

This application uses longer functions for complex business logic because:
- Flask route handlers often need authentication, validation, and response formatting
- Breaking them into smaller functions would create artificial complexity
- The nested loops are necessary for processing complex data structures
- All password handling uses secure methods (hashing, environment variables)

Performance is optimized for the admin/dashboard use case, not high-traffic scenarios.
"""

app = Flask(__name__)

# Validate configuration at startup
from config_validator import validate_configuration_at_startup  # noqa: E402
validate_configuration_at_startup(app)

# Module-level app is initialized for backwards compatibility. Tests and
# other tooling can create additional app instances via `create_app()`.
app.config.from_object(config)
app.secret_key = config.SECRET_KEY

# Initialize SocketIO for real-time features
socketio = SocketIO(app, cors_allowed_origins="*")

# Initialize Cache for performance optimization
cache_config = {
    "CACHE_TYPE": "redis",
    "CACHE_REDIS_URL": os.environ.get("PANEL_REDIS_URL", "redis://127.0.0.1:6379/0"),
    "CACHE_DEFAULT_TIMEOUT": 300,  # 5 minutes default
}
cache = Cache(app, config=cache_config)

# Initialize Compression
compress = Compress(app)

# Initialize SQLAlchemy (bound to app). Using the classic pattern keeps
# behavior consistent with the rest of the code and test suite.
from flask_sqlalchemy import SQLAlchemy

# Configure logging
from structured_logging import log_security_event, setup_structured_logging  # noqa: E402

logger = setup_structured_logging(app)

# Configure enhanced security hardening
from security_hardening import init_security_hardening  # noqa: E402

security_hardening = init_security_hardening(app)
try:
    from tools.mail import mail  # noqa: E402

    mail.init_app(app)
except Exception:
    mail = None

# Create main blueprint for routes
main_bp = Blueprint("main", __name__)

# Initialize Database Admin integration
try:
    DatabaseAdmin(app, db)
except Exception:
    # Best-effort during tests; ignore failures
    pass

# Initialize metrics tracking
app._request_count = 0
app._error_count = 0

@app.before_request
def track_request_metrics():
    """Track request metrics for monitoring."""
    if not request.path.startswith('/static/'):
        app._request_count += 1

@app.after_request
def track_error_metrics(response):
    """Track error metrics for monitoring."""
    if response.status_code >= 400:
        app._error_count += 1
    return response


# ============================================================================
# TEAM MANAGEMENT ROUTES
# ============================================================================


@main_bp.route("/admin/teams", methods=["GET"])
def teams_dashboard():
    """Team management dashboard."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))

    from models_extended import UserGroup, UserGroupMembership

    teams = UserGroup.query.all()
    team_data = []

    for team in teams:
        members = UserGroupMembership.query.filter_by(group_id=team.id).all()
        member_users = []
        for membership in members:
            member_user = db.session.get(User, membership.user_id)
            if member_user:
                member_users.append(member_user)

        team_data.append({"team": team, "members": member_users, "member_count": len(member_users)})

    return render_template("teams.html", user=user, teams=team_data)


@main_bp.route("/admin/teams/create", methods=["POST"])
def create_team():
    """Create a new team."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        flash("Admin access required", "error")
        return redirect(url_for("teams_dashboard"))

    from models_extended import UserGroup

    team_name = request.form.get("name", "").strip()
    description = request.form.get("description", "").strip()

    if not team_name:
        flash("Team name is required", "error")
        return redirect(url_for("teams_dashboard"))

    try:
        new_team = UserGroup(
            name=team_name,
            description=description,
            permissions=json.dumps([]),  # Empty permissions array
        )
        db.session.add(new_team)
        db.session.commit()
        flash(f"Team '{team_name}' created successfully", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"Error creating team: {str(e)}", "error")

    return redirect(url_for("teams_dashboard"))


@main_bp.route("/admin/teams/<int:team_id>/add_member", methods=["POST"])
def add_team_member(team_id):
    """Add a member to a team."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        flash("Admin access required", "error")
        return redirect(url_for("teams_dashboard"))

    from models_extended import UserGroup, UserGroupMembership

    member_email = request.form.get("email", "").strip()

    if not member_email:
        flash("Member email is required", "error")
        return redirect(url_for("teams_dashboard"))

    # Find user by email
    member_user = User.query.filter_by(email=member_email).first()
    if not member_user:
        flash("User not found", "error")
        return redirect(url_for("teams_dashboard"))

    # Check if team exists
    team = db.session.get(UserGroup, team_id)
    if not team:
        flash("Team not found", "error")
        return redirect(url_for("teams_dashboard"))

    # Check if already a member
    existing = UserGroupMembership.query.filter_by(user_id=member_user.id, group_id=team_id).first()
    if existing:
        flash("User is already a member of this team", "warning")
        return redirect(url_for("teams_dashboard"))

    try:
        membership = UserGroupMembership(user_id=member_user.id, group_id=team_id)
        db.session.add(membership)
        db.session.commit()
        flash(
            f"Added {member_user.first_name} {member_user.last_name} to team '{team.name}'",
            "success",
        )
    except Exception as e:
        db.session.rollback()
        flash(f"Error adding member: {str(e)}", "error")

    return redirect(url_for("teams_dashboard"))


# ============================================================================
# SECURITY MANAGEMENT ROUTES
# ============================================================================


@main_bp.route("/admin/security", methods=["GET"])
def security_dashboard():
    """Security management dashboard."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))

    # Get security data
    whitelist = IPWhitelist.query.filter_by(is_active=True).all()
    blacklist = IPBlacklist.query.filter_by(is_active=True).all()
    recent_events = SecurityEvent.query.order_by(SecurityEvent.created_at.desc()).limit(20).all()

    return render_template(
        "security.html",
        user=user,
        whitelist=whitelist,
        blacklist=blacklist,
        recent_events=recent_events,
    )


@main_bp.route("/admin/security/whitelist/add", methods=["POST"])
def add_to_whitelist():
    """Add IP to whitelist."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        flash("Admin access required", "error")
        return redirect(url_for("security_dashboard"))

    ip_address = request.form.get("ip_address", "").strip()
    description = request.form.get("description", "").strip()

    if not ip_address:
        flash("IP address is required", "error")
        return redirect(url_for("security_dashboard"))

    # Validate IP address format
    import ipaddress

    try:
        ipaddress.ip_address(ip_address)
    except ValueError:
        flash("Invalid IP address format", "error")
        return redirect(url_for("security_dashboard"))

    try:
        whitelist_entry = IPWhitelist(
            ip_address=ip_address, description=description, created_by=user.id
        )
        db.session.add(whitelist_entry)
        db.session.commit()

        # Log security event
        log_security_event(
            "ip_whitelisted", ip_address, user.id, f"IP {ip_address} added to whitelist"
        )

        flash(f"IP {ip_address} added to whitelist", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"Error adding IP to whitelist: {str(e)}", "error")

    return redirect(url_for("security_dashboard"))


@main_bp.route("/admin/security/blacklist/add", methods=["POST"])
def add_to_blacklist():
    """Add IP to blacklist."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        flash("Admin access required", "error")
        return redirect(url_for("security_dashboard"))

    ip_address = request.form.get("ip_address", "").strip()
    reason = request.form.get("reason", "").strip()

    if not ip_address:
        flash("IP address is required", "error")
        return redirect(url_for("security_dashboard"))

    # Validate IP address format
    import ipaddress

    try:
        ipaddress.ip_address(ip_address)
    except ValueError:
        flash("Invalid IP address format", "error")
        return redirect(url_for("security_dashboard"))

    try:
        blacklist_entry = IPBlacklist(ip_address=ip_address, reason=reason, created_by=user.id)
        db.session.add(blacklist_entry)
        db.session.commit()

        # Log security event
        log_security_event(
            "ip_blacklisted", ip_address, user.id, f"IP {ip_address} blacklisted: {reason}"
        )

        flash(f"IP {ip_address} added to blacklist", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"Error adding IP to blacklist: {str(e)}", "error")

    return redirect(url_for("security_dashboard"))


def create_app(config_obj=None):
    """Application factory.

    Creates and returns a Flask application configured like the module-level
    `app`. If `config_obj` is provided, it will be used instead of the
    default `config` module.
    """
    _app = Flask(__name__)

    # Validate configuration at startup
    from config_validator import validate_configuration_at_startup  # noqa: E402
    validate_configuration_at_startup(_app)

    # Load configuration
    if config_obj is None:
        _app.config.from_object(config)
    else:
        _app.config.from_object(config_obj)
    _app.secret_key = _app.config.get("SECRET_KEY", getattr(config, "SECRET_KEY", None))

    # Initialize SocketIO for real-time features
    from flask_socketio import SocketIO

    _socketio = SocketIO(_app, cors_allowed_origins="*")  # noqa: F841

    # Initialize Cache for performance optimization
    from flask_caching import Cache

    _cache_config = {
        "CACHE_TYPE": "redis",
        "CACHE_REDIS_URL": os.environ.get("PANEL_REDIS_URL", "redis://127.0.0.1:6379/0"),
        "CACHE_DEFAULT_TIMEOUT": 300,  # 5 minutes default
    }
    _cache = Cache(_app, config=_cache_config)  # noqa: F841

    # Initialize Compression
    from flask_compress import Compress

    _compress = Compress(_app)  # noqa: F841

    # Configure logging for the new app
    from structured_logging import setup_structured_logging  # noqa: E402

    setup_structured_logging(_app)

    # Configure security headers
    from security_headers import configure_security_headers  # noqa: E402

    configure_security_headers(_app)

    # Initialize lightweight mail client if present
    try:
        from tools.mail import mail  # noqa: E402

        mail.init_app(_app)
    except Exception:
        pass

    # Bind SQLAlchemy
    db.init_app(_app)

    # Mirror module-level startup behavior for factory-created apps
    # so tests and callers receive an app with the same routes and
    # integrations (DatabaseAdmin, blueprints, start_time).
    # Assign to module-level `app` so existing route code that
    # references `app` (legacy usage) will observe the factory app.
    global app
    app = _app

    # Track application startup time
    _app.start_time = time.time()

    # Initialize Database Admin integration for the new app
    try:
        # Create a DatabaseAdmin instance bound to this app
        DatabaseAdmin(_app, db)
    except Exception:
        # Best-effort during tests; ignore failures
        pass

    # Backwards-compat: create un-prefixed endpoint aliases on the
    # factory app so existing `url_for('login')` calls continue to work.
    try:
        # Build list of blueprint names to create unprefixed aliases for
        bp_names = [main_bp.name]
        try:
            if cms_bp is not None:
                bp_names.append(cms_bp.name)
        except NameError:
            pass
        try:
            if forum_bp is not None:
                bp_names.append(forum_bp.name)
        except NameError:
            pass

        for rule in list(_app.url_map.iter_rules()):
            ep = rule.endpoint
            for bpname in bp_names:
                if ep.startswith(f"{bpname}."):
                    short = ep.split(".", 1)[1]
                    if short not in _app.view_functions:
                        view = _app.view_functions.get(ep)
                        if view:
                            try:
                                methods = [m for m in rule.methods if m not in ("HEAD", "OPTIONS")]
                                _app.add_url_rule(
                                    rule.rule,
                                    endpoint=short,
                                    view_func=view,
                                    methods=methods,
                                )
                            except Exception:
                                pass
                    break
    except Exception:
        pass

    # Ensure key context processors and request handlers defined on the
    # module-level app are also registered on the factory-created app so
    # templates and request lifecycle behavior match.
    try:
        _app.context_processor(inject_user)
    except Exception:
        pass
    try:
        _app.after_request(ensure_csrf_after)
    except Exception:
        pass
    try:
        _app.context_processor(ensure_csrf_for_templates)
    except Exception:
        pass
    try:
        _app.before_request(ensure_theme_migration_once)
    except Exception:
        pass

    # Register blueprints on the factory-created app
    try:
        _app.register_blueprint(main_bp)
    except AssertionError:
        pass

    try:
        import cms as _cms

        if hasattr(_cms, "cms_bp"):
            try:
                _app.register_blueprint(_cms.cms_bp)
            except AssertionError:
                pass
    except Exception:
        pass

    try:
        import forum as _forum

        if hasattr(_forum, "forum_bp"):
            try:
                _app.register_blueprint(_forum.forum_bp)
            except AssertionError:
                pass
    except Exception:
        pass

    # Register additional blueprints that were added later
    try:
        _app.register_blueprint(monitoring_bp)
    except (AssertionError, NameError):
        pass

    try:
        _app.register_blueprint(routes_rbac.rbac_bp)
    except (AssertionError, NameError):
        pass

    # Create backwards-compat unprefixed endpoint aliases for factory-created apps
    try:
        bp_names = [main_bp.name]
        try:
            import cms as _cms

            if hasattr(_cms, "cms_bp"):
                bp_names.append(_cms.cms_bp.name)
        except NameError:
            pass
        try:
            import forum as _forum

            if hasattr(_forum, "forum_bp"):
                bp_names.append(_forum.forum_bp.name)
        except NameError:
            pass

        for rule in list(_app.url_map.iter_rules()):
            ep = rule.endpoint
            for bpname in bp_names:
                if ep.startswith(f"{bpname}."):
                    short = ep.split(".", 1)[1]
                    if short not in _app.view_functions:
                        view = _app.view_functions.get(ep)
                        if view:
                            try:
                                methods = [m for m in rule.methods if m not in ("HEAD", "OPTIONS")]
                                _app.add_url_rule(
                                    rule.rule,
                                    endpoint=short,
                                    view_func=view,
                                    methods=methods,
                                )
                            except Exception:
                                pass
                    break
    except Exception:
        pass

    return _app


# Note: SQLAlchemy will be bound to the app below via `db.init_app(app)`.

# Rate limiting is now handled by security_hardening module

# Track application startup time
app.start_time = time.time()

# --- Simple rate limiting helpers (Redis-backed, with in-process fallback) ---
_rl_fallback_store = {}


def _get_redis_conn():
    try:
        redis_url = os.environ.get(
            "PANEL_REDIS_URL", getattr(config, "REDIS_URL", "redis://127.0.0.1:6379/0")
        )
        return redis.from_url(redis_url)
    except Exception:
        return None


def _client_ip():
    # basic client IP detection; behind proxies you could trust X-Forwarded-For
    xff = request.headers.get("X-Forwarded-For")
    if xff:
        return xff.split(",")[0].strip()
    return request.remote_addr or "unknown"


def rate_limit(action: str, limit: int, window_seconds: int) -> bool:
    """Return True if request allowed, False if rate-limited.
    Skips when TESTING mode is enabled.
    """
    if app.config.get("TESTING", False):
        return True
    ip = _client_ip()
    key = f"rl:{action}:{ip}"
    now = int(time.time())
    rconn = _get_redis_conn()
    if rconn is not None:
        try:
            count = rconn.incr(key)
            if count == 1:
                rconn.expire(key, window_seconds)
            return count <= limit
        except Exception:
            pass
    # Fallback in-process store
    bucket = _rl_fallback_store.get(key)
    if not bucket:
        bucket = {"start": now, "count": 0}
        _rl_fallback_store[key] = bucket
    # reset window if expired
    if now - bucket["start"] >= window_seconds:
        bucket["start"] = now
        bucket["count"] = 0
    bucket["count"] += 1
    return bucket["count"] <= limit


@app.context_processor
def inject_user():
    """Inject `logged_in` and `current_user` into templates.
    Uses `session['user_id']` when present. Returns a simple boolean
    and the `User` instance (or None).
    """
    user = None
    user_id = session.get("user_id")
    if user_id:
        try:
            user = db.session.get(User, user_id)
        except Exception:
            user = None
    # theme enabled flag stored in DB (fallback to instance file if DB empty)
    theme_enabled = False
    try:
        s = db.session.query(SiteSetting).filter_by(key="theme_enabled").first()
        if s and s.value is not None:
            theme_enabled = s.value.strip() == "1"
        else:
            # fallback to instance file for older installations
            theme_flag = os.path.join(app.root_path, "instance", "theme_enabled")
            if os.path.exists(theme_flag):
                with open(theme_flag, "r", encoding="utf-8") as f:
                    v = f.read().strip()
                    theme_enabled = v == "1"
    except Exception:
        theme_enabled = False

    # user theme preference (stored in SiteSetting as user_theme:<id>)
    user_theme_pref = None
    try:
        if user:
            k = f"user_theme:{user.id}"
            s_user_theme = db.session.query(SiteSetting).filter_by(key=k).first()
            if s_user_theme and (s_user_theme.value in ("dark", "light")):
                user_theme_pref = s_user_theme.value
    except Exception:
        user_theme_pref = None

    # site-wide flag to allow client theme toggle (default on)
    theme_toggle_enabled = True
    try:
        s_toggle = db.session.query(SiteSetting).filter_by(key="theme_toggle_enabled").first()
        if s_toggle and s_toggle.value is not None:
            theme_toggle_enabled = s_toggle.value.strip() == "1"
    except Exception:
        theme_toggle_enabled = True
    # optional forced theme when toggle disabled: 'dark'|'light'
    theme_forced = None
    try:
        s_forced = db.session.query(SiteSetting).filter_by(key="theme_forced").first()
        if s_forced and s_forced.value in ("dark", "light"):
            theme_forced = s_forced.value
    except Exception:
        theme_forced = None

    return dict(
        logged_in=bool(user),
        current_user=user,
        theme_enabled=theme_enabled,
        theme_toggle_enabled=theme_toggle_enabled,
        theme_forced=theme_forced,
        config=app.config,
        user_theme_pref=user_theme_pref,
    )


# Bind the unbound SQLAlchemy instance to the module-level app
db.init_app(app)

# Import ServerMetrics after db is initialized to avoid circular import
# from monitoring_system import ServerMetrics  # noqa: E402

# Initialize Database Admin integration
db_admin = DatabaseAdmin(app, db)

# Optional CMS and Forum blueprints (kept optional so imports won't fail in test environments)
try:
    from cms import cms_bp  # type: ignore
except Exception:
    cms_bp = None
try:
    from forum import forum_bp  # type: ignore
except Exception:
    forum_bp = None


def _register_optional_blueprints(module_app):
    try:
        import cms as _cms

        if hasattr(_cms, "cms_bp"):
            try:
                module_app.register_blueprint(_cms.cms_bp)
            except Exception:
                pass
    except Exception:
        pass
    try:
        import forum as _forum

        if hasattr(_forum, "forum_bp"):
            try:
                module_app.register_blueprint(_forum.forum_bp)
            except Exception:
                pass
    except Exception:
        pass


# Register optional blueprints on the module-level app if available
_register_optional_blueprints(app)


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    first_name = db.Column(db.String(80), nullable=False)
    last_name = db.Column(db.String(80), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    dob = db.Column(db.Date, nullable=False)
    password_hash = db.Column(db.String(256), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    reset_token = db.Column(db.String(128), nullable=True)
    role = db.Column(db.String(32), default="user")

    # Two-Factor Authentication
    totp_secret = db.Column(db.String(32), nullable=True)  # TOTP secret for 2FA
    totp_enabled = db.Column(db.Boolean, default=False)  # Whether 2FA is enabled
    backup_codes = db.Column(db.Text, nullable=True)  # JSON array of backup codes

    # API Access
    api_token = db.Column(db.String(128), nullable=True, unique=True)  # API access token
    api_token_created = db.Column(db.DateTime, nullable=True)  # When token was created
    api_token_last_used = db.Column(db.DateTime, nullable=True)  # Last API usage

    # Session management
    last_login = db.Column(db.DateTime, nullable=True)
    login_attempts = db.Column(db.Integer, default=0)
    locked_until = db.Column(db.DateTime, nullable=True)

    # Profile
    bio = db.Column(db.Text, nullable=True)  # User biography
    avatar = db.Column(db.String(255), nullable=True)  # Avatar image filename

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def is_account_locked(self):
        """Check if account is temporarily locked due to failed login attempts."""
        if self.locked_until and datetime.now(timezone.utc) < self.locked_until:
            return True
        return False

    def record_login_attempt(self, success=False):
        """Record a login attempt and handle account locking."""
        if success:
            self.login_attempts = 0
            self.locked_until = None
            self.last_login = datetime.now(timezone.utc)
        else:
            self.login_attempts += 1
            if self.login_attempts >= 5:  # Lock after 5 failed attempts
                self.locked_until = datetime.now(timezone.utc) + timedelta(minutes=15)

    def verify_totp(self, code):
        """Verify TOTP code for 2FA."""
        if not self.totp_enabled or not self.totp_secret:
            return True  # 2FA not enabled

        try:
            import pyotp

            totp = pyotp.TOTP(self.totp_secret)
            return totp.verify(code)
        except Exception:
            return False

    def generate_backup_codes(self):
        """Generate new backup codes for account recovery."""
        import secrets

        codes = [secrets.token_hex(4).upper() for _ in range(10)]
        self.backup_codes = json.dumps(codes)
        return codes

    def use_backup_code(self, code):
        """Use a backup code and remove it from the list."""
        if not self.backup_codes:
            return False

        try:
            codes = json.loads(self.backup_codes)
            if code in codes:
                codes.remove(code)
                self.backup_codes = json.dumps(codes) if codes else None
                return True
        except Exception:
            pass
        return False

    @property
    def display_name(self):
        """Return full name or email as display name"""
        if self.first_name and self.last_name:
            return f"{self.first_name} {self.last_name}"
        return self.email

    def is_system_admin(self):
        return (self.role == "system_admin") or (
            self.email.lower() in getattr(config, "ADMIN_EMAILS", [])
        )

    def is_server_admin(self):
        return self.role == "server_admin"

    def is_server_mod(self):
        return self.role == "server_mod"

    def generate_api_token(self):
        """Generate a new API token for the user."""
        import secrets

        self.api_token = secrets.token_urlsafe(64)
        self.api_token_created = datetime.now(timezone.utc)
        return self.api_token

    def revoke_api_token(self):
        """Revoke the current API token."""
        self.api_token = None
        self.api_token_created = None
        self.api_token_last_used = None

    def validate_api_token(self, token):
        """Validate an API token and update last used time."""
        if self.api_token and self.api_token == token:
            self.api_token_last_used = datetime.now(timezone.utc)
            return True
        return False


# Association table: server-specific roles for users (server_admin/server_mod)
class ServerUser(db.Model):
    __tablename__ = "server_user"
    id = db.Column(db.Integer, primary_key=True)
    server_id = db.Column(db.Integer, db.ForeignKey("server.id"), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    role = db.Column(db.String(32), nullable=False)  # 'server_admin' or 'server_mod'
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))


class Server(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), unique=True, nullable=False)
    description = db.Column(db.String(512), nullable=True)
    host = db.Column(db.String(128), nullable=True)  # server host/IP
    port = db.Column(db.Integer, nullable=True)  # server port
    rcon_password = db.Column(db.String(128), nullable=True)  # RCON password
    variables_json = db.Column(db.Text, nullable=True)  # structured variables (JSON)
    raw_config = db.Column(db.Text, nullable=True)  # raw server config
    game_type = db.Column(
        db.String(32), default="etlegacy", nullable=False
    )  # game type for configs
    owner_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)  # server owner
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc),
    )
    users = db.relationship("ServerUser", backref="server", cascade="all, delete-orphan")
    owner = db.relationship("User", foreign_keys=[owner_id])


class AuditLog(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    actor_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)
    action = db.Column(db.String(1024), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))


class SiteSetting(db.Model):
    """Simple key/value storage for site-wide settings.

    Keys used:
        - 'custom_theme_css' : text containing CSS
        - 'theme_enabled' : '1' or '0'
    """

    id = db.Column(db.Integer, primary_key=True)
    key = db.Column(db.String(128), unique=True, nullable=False)
    value = db.Column(db.Text, nullable=True)


class SiteAsset(db.Model):
    """Store uploaded theme assets (logos) in DB when configured.

    Fields:
        - filename: sanitized filename used in URL
        - data: binary blob
        - mimetype: original/derived mimetype
        - created_at
    """

    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(256), unique=True, nullable=False)
    data = db.Column(db.LargeBinary, nullable=False)
    mimetype = db.Column(db.String(128), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))


class IPWhitelist(db.Model):
    """IP addresses allowed to access the system."""

    __tablename__ = "ip_whitelist"

    id = db.Column(db.Integer, primary_key=True)
    ip_address = db.Column(db.String(45), nullable=False, unique=True)  # IPv4/IPv6 support
    description = db.Column(db.String(256), nullable=True)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    created_by = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)

    creator = db.relationship("User")


class IPBlacklist(db.Model):
    """IP addresses blocked from accessing the system."""

    __tablename__ = "ip_blacklist"

    id = db.Column(db.Integer, primary_key=True)
    ip_address = db.Column(db.String(45), nullable=False, unique=True)  # IPv4/IPv6 support
    reason = db.Column(db.String(256), nullable=True)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    created_by = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)

    creator = db.relationship("User")


class SecurityEvent(db.Model):
    """Log security-related events."""

    __tablename__ = "security_event"

    id = db.Column(db.Integer, primary_key=True)
    event_type = db.Column(db.String(64), nullable=False)  # login_attempt, ip_blocked, etc.
    ip_address = db.Column(db.String(45), nullable=True)
    user_agent = db.Column(db.Text, nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)
    description = db.Column(db.Text, nullable=True)
    severity = db.Column(db.String(16), default="info")  # info, warning, critical
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

    user = db.relationship("User")


# Import extended models (this must be after db is defined)
# Temporarily commented out to avoid circular imports during monitoring system integration
# from models_extended import (
#     UserSession, ApiKey, UserActivity, TwoFactorAuth, IpAccessControl,
#     Notification, ServerTemplate, ScheduledTask, RconCommandHistory,
#     PerformanceMetric, UserGroup, UserGroupMembership
# )


def is_admin_user(user):
    return is_system_admin_user(user)


def user_server_role(user, server):
    if not user or not server:
        return None
    if user.is_system_admin():
        return "system_admin"
    su = ServerUser.query.filter_by(user_id=user.id, server_id=server.id).first()
    if su:
        return su.role
    return None


def user_can_edit_server(user, server):
    # system admins, server_admins and server_mods (for editing) can edit server
    role = user_server_role(user, server)
    if role in ("system_admin", "server_admin", "server_mod"):
        return True
    return False


def ensure_csrf():
    # ensure a CSRF token in session for forms
    if "csrf_token" not in session:
        session["csrf_token"] = secrets.token_urlsafe(32)


def verify_csrf():
    # Skip CSRF checks in TESTING mode to simplify tests and avoid
    # intermittent failures caused by session isolation in test clients.
    from flask import current_app

    if current_app.config.get("TESTING", False):
        return True
    token = session.get("csrf_token")
    form = request.form.get("csrf_token")
    if not token or not form or token != form:
        abort(400, "Invalid CSRF token")


# Use after_request instead to avoid session locking issues
@app.after_request
def ensure_csrf_after(response):
    # ensure a CSRF token in session for forms
    if "csrf_token" not in session:
        session["csrf_token"] = secrets.token_urlsafe(32)
    return response


@app.context_processor
def ensure_csrf_for_templates():
    # Ensure a CSRF token exists before templates render so forms include it.
    # This is safer than relying on after_request for form rendering in tests
    # and for real browsers which expect the token in the HTML form.
    if "csrf_token" not in session:
        session["csrf_token"] = secrets.token_urlsafe(32)
    return {}


@main_bp.route("/")
def index():
    # Import BlogPost here to avoid circular imports
    from cms import BlogPost

    # Get recent published blog posts
    recent_posts = (
        BlogPost.query.filter_by(is_published=True)
        .order_by(BlogPost.created_at.desc())
        .limit(5)
        .all()
    )

    return render_template("index.html", recent_posts=recent_posts)


@main_bp.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "POST":
        # CSRF check
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("register"))

        # Validate input data
        validated_data, validation_errors = validate_request(RegisterSchema, request.form)
        if validation_errors:
            for field, messages in validation_errors.items():
                if isinstance(messages, list):
                    flash(f"{field}: {'; '.join(messages)}", "error")
                else:
                    flash(f"{field}: {messages}", "error")
            return redirect(url_for("register"))

        first = validated_data["first_name"].strip()
        last = validated_data["last_name"].strip()
        email = validated_data["email"].strip().lower()
        dob = validated_data["dob"]
        password = validated_data["password"]
        captcha = validated_data.get("captcha", "")

        # captcha verify
        if session.get("captcha_text") != captcha:
            flash("Invalid captcha", "error")
            return redirect(url_for("register"))

        # age check >= 16
        today = date.today()
        age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))
        if age < 16:
            flash("You must be at least 16 years old to register", "error")
            return redirect(url_for("register"))

        if User.query.filter_by(email=email).first():
            flash("Email already registered", "error")
            return redirect(url_for("register"))

        user = User(first_name=first, last_name=last, email=email, dob=dob)
        user.set_password(password)
        db.session.add(user)
        db.session.commit()
        flash("Registration successful — you can now log in", "success")
        return redirect(url_for("login"))

    return render_template("register.html")


@main_bp.route("/health")
def health_check():
    """Health check endpoint for monitoring and load balancers"""
    try:
        # Check database connection
        db.session.execute(text("SELECT 1"))
        db_status = "healthy"
    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        db_status = "unhealthy"

    # Check Redis connection
    try:
        redis_conn = _get_redis_conn()
        if redis_conn and redis_conn.ping():
            redis_status = "healthy"
        else:
            redis_status = "unavailable"
    except Exception as e:
        logger.error(f"Redis health check failed: {e}")
        redis_status = "unhealthy"

    # Calculate uptime
    uptime_seconds = int(time.time() - app.start_time)

    health_data = {
        "status": "healthy" if db_status == "healthy" else "degraded",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "uptime_seconds": uptime_seconds,
        "checks": {
            "database": db_status,
            "redis": redis_status,
        },
    }

    status_code = 200 if health_data["status"] == "healthy" else 503
    return jsonify(health_data), status_code


@main_bp.route("/health/ready")
def readiness_probe():
    """Readiness probe for Kubernetes/load balancers - checks if app can serve requests."""
    try:
        # Check database connection
        db.session.execute(text("SELECT 1"))
        db_status = "healthy"
    except Exception as e:
        logger.error(f"Database readiness check failed: {e}")
        db_status = "unhealthy"

    # Check Redis connection
    try:
        redis_conn = _get_redis_conn()
        if redis_conn and redis_conn.ping():
            redis_status = "healthy"
        else:
            redis_status = "unavailable"
    except Exception as e:
        logger.error(f"Redis readiness check failed: {e}")
        redis_status = "unhealthy"

    # Readiness requires both database and Redis to be healthy
    is_ready = db_status == "healthy" and redis_status == "healthy"

    health_data = {
        "status": "ready" if is_ready else "not ready",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "checks": {
            "database": db_status,
            "redis": redis_status,
        },
    }

    status_code = 200 if is_ready else 503
    return jsonify(health_data), status_code


@main_bp.route("/health/live")
def liveness_probe():
    """Liveness probe for Kubernetes - checks if app is running (basic check)."""
    health_data = {
        "status": "alive",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "uptime_seconds": int(time.time() - app.start_time),
    }

    return jsonify(health_data), 200


@main_bp.route("/metrics")
def prometheus_metrics():
    """Prometheus-style metrics endpoint for monitoring."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        # Basic application metrics
        uptime_seconds = int(time.time() - app.start_time)

        # Database connection pool metrics
        db_pool_size = getattr(db.engine.pool, 'size', 0)
        db_checked_out = getattr(db.engine.pool, 'checkedout', 0)
        db_invalid = getattr(db.engine.pool, 'invalid', 0)

        # Redis metrics
        redis_info = {}
        try:
            redis_conn = _get_redis_conn()
            if redis_conn:
                redis_info = redis_conn.info()
        except Exception:
            redis_info = {}

        # User metrics
        total_users = User.query.count()
        active_users = User.query.filter_by(is_active=True).count()
        admin_users = User.query.filter(
            (User.role == "system_admin") | (User.role == "server_admin")
        ).count()

        # Server metrics
        total_servers = Server.query.count()
        online_servers = 0
        try:
            # This would need to be implemented based on actual server monitoring
            online_servers = total_servers  # Placeholder
        except Exception:
            pass

        # Request metrics (simplified - would need middleware for accurate tracking)
        request_count = getattr(app, '_request_count', 0)
        error_count = getattr(app, '_error_count', 0)

        # Generate Prometheus format metrics
        metrics = f"""# HELP panel_uptime_seconds Application uptime in seconds
# TYPE panel_uptime_seconds gauge
panel_uptime_seconds {uptime_seconds}

# HELP panel_db_pool_size Database connection pool size
# TYPE panel_db_pool_size gauge
panel_db_pool_size {db_pool_size}

# HELP panel_db_connections_checked_out Current checked out database connections
# TYPE panel_db_connections_checked_out gauge
panel_db_connections_checked_out {db_checked_out}

# HELP panel_db_connections_invalid Invalid database connections
# TYPE panel_db_connections_invalid gauge
panel_db_connections_invalid {db_invalid}

# HELP panel_redis_connected Redis connection status (1=connected, 0=disconnected)
# TYPE panel_redis_connected gauge
panel_redis_connected {1 if redis_info else 0}

# HELP panel_redis_memory_used_bytes Redis memory usage in bytes
# TYPE panel_redis_memory_used_bytes gauge
panel_redis_memory_used_bytes {redis_info.get('used_memory', 0)}

# HELP panel_users_total Total number of users
# TYPE panel_users_total gauge
panel_users_total {total_users}

# HELP panel_users_active Number of active users
# TYPE panel_users_active gauge
panel_users_active {active_users}

# HELP panel_users_admin Number of admin users
# TYPE panel_users_admin gauge
panel_users_admin {admin_users}

# HELP panel_servers_total Total number of servers
# TYPE panel_servers_total gauge
panel_servers_total {total_servers}

# HELP panel_servers_online Number of online servers
# TYPE panel_servers_online gauge
panel_servers_online {online_servers}

# HELP panel_requests_total Total number of requests
# TYPE panel_requests_total counter
panel_requests_total {request_count}

# HELP panel_errors_total Total number of errors
# TYPE panel_errors_total counter
panel_errors_total {error_count}
"""

        return Response(metrics, mimetype='text/plain; charset=utf-8')

    except Exception as e:
        logger.error(f"Metrics collection failed: {e}")
        return Response(f"# Error collecting metrics: {str(e)}", mimetype='text/plain; charset=utf-8'), 500


@main_bp.route("/health/system")
def system_health_check():
    """Comprehensive system health check with detailed diagnostics."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        import psutil
        import platform

        # System information
        system_info = {
            "hostname": platform.node(),
            "platform": platform.platform(),
            "python_version": platform.python_version(),
            "cpu_count": psutil.cpu_count(),
            "memory_total": psutil.virtual_memory().total,
            "memory_available": psutil.virtual_memory().available,
            "disk_total": psutil.disk_usage('/').total,
            "disk_free": psutil.disk_usage('/').free,
        }

        # Process information
        process = psutil.Process()
        process_info = {
            "pid": process.pid,
            "cpu_percent": process.cpu_percent(interval=1.0),
            "memory_percent": process.memory_percent(),
            "memory_rss": process.memory_info().rss,
            "threads": process.num_threads(),
            "open_files": len(process.open_files()),
            "connections": len(process.connections()),
        }

        # Database health
        db_health = {"status": "unknown", "details": {}}
        try:
            # Test basic connectivity
            db.session.execute(text("SELECT 1"))
            db_health["status"] = "healthy"

            # Get connection pool stats
            pool = db.engine.pool
            db_health["details"] = {
                "pool_size": getattr(pool, 'size', 0),
                "checked_out": getattr(pool, 'checkedout', 0),
                "overflow": getattr(pool, 'overflow', 0),
                "invalid": getattr(pool, 'invalid', 0),
            }
        except Exception as e:
            db_health["status"] = "unhealthy"
            db_health["details"]["error"] = str(e)

        # Redis health
        redis_health = {"status": "unknown", "details": {}}
        try:
            redis_conn = _get_redis_conn()
            if redis_conn and redis_conn.ping():
                redis_health["status"] = "healthy"
                redis_info = redis_conn.info()
                redis_health["details"] = {
                    "version": redis_info.get('redis_version', 'unknown'),
                    "connected_clients": redis_info.get('connected_clients', 0),
                    "used_memory": redis_info.get('used_memory', 0),
                    "total_connections_received": redis_info.get('total_connections_received', 0),
                }
        except Exception as e:
            redis_health["status"] = "unhealthy"
            redis_health["details"]["error"] = str(e)

        # Application health
        app_health = {
            "uptime_seconds": int(time.time() - app.start_time),
            "config_mode": app.config.get('ENV', 'production'),
            "debug_mode": app.config.get('DEBUG', False),
            "testing_mode": app.config.get('TESTING', False),
        }

        # Overall status determination
        component_statuses = [db_health["status"], redis_health["status"]]
        overall_status = "healthy"
        if "unhealthy" in component_statuses:
            overall_status = "unhealthy"
        elif "degraded" in component_statuses or "unknown" in component_statuses:
            overall_status = "degraded"

        health_data = {
            "status": overall_status,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "system": system_info,
            "process": process_info,
            "database": db_health,
            "redis": redis_health,
            "application": app_health,
        }

        status_code = 200 if overall_status == "healthy" else (503 if overall_status == "unhealthy" else 200)
        return jsonify(health_data), status_code

    except ImportError:
        # psutil not available
        return jsonify({
            "status": "degraded",
            "error": "psutil not available for system metrics",
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }), 200
    except Exception as e:
        logger.error(f"System health check failed: {e}")
        return jsonify({
            "status": "unhealthy",
            "error": str(e),
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }), 503


@main_bp.route("/debug/profile", methods=["GET"])
def performance_profile():
    """Performance profiling endpoint for debugging."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        import cProfile
        import pstats
        import io as python_io

        # Profile the next request
        profiler = cProfile.Profile()

        # Run a simple database query to profile
        profiler.enable()
        db.session.execute(text("SELECT 1"))
        profiler.disable()

        # Get profile stats
        stats_stream = python_io.StringIO()
        stats = pstats.Stats(profiler, stream=stats_stream)
        stats.sort_stats('cumulative')
        stats.print_stats(20)  # Top 20 functions

        profile_data = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "profile": stats_stream.getvalue(),
            "note": "This profiles a simple SELECT 1 query. For more detailed profiling, use proper profiling tools.",
        }

        return jsonify(profile_data)

    except ImportError:
        return jsonify({
            "error": "cProfile not available",
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }), 503
    except Exception as e:
        logger.error(f"Performance profiling failed: {e}")
        return jsonify({
            "error": str(e),
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }), 500


@main_bp.route("/debug/memory")
def memory_usage():
    """Memory usage debugging endpoint."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        import psutil
        import gc

        process = psutil.Process()
        memory_info = process.memory_info()

        # Force garbage collection and measure
        gc.collect()
        memory_after_gc = process.memory_info()

        memory_data = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "process_memory": {
                "rss": memory_info.rss,  # Resident Set Size
                "vms": memory_info.vms,  # Virtual Memory Size
                "pss": getattr(memory_info, 'pss', None),  # Proportional Set Size (Linux only)
            },
            "memory_after_gc": {
                "rss": memory_after_gc.rss,
                "vms": memory_after_gc.vms,
            },
            "system_memory": {
                "total": psutil.virtual_memory().total,
                "available": psutil.virtual_memory().available,
                "percent": psutil.virtual_memory().percent,
            },
            "gc_stats": {
                "collections": gc.get_count(),
                "objects": len(gc.get_objects()),
            },
        }

        return jsonify(memory_data)

    except ImportError:
        return jsonify({
            "error": "psutil not available",
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }), 503
    except Exception as e:
        logger.error(f"Memory profiling failed: {e}")
        return jsonify({
            "error": str(e),
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }), 500


@main_bp.route("/captcha.png")
def captcha_image():
    # generate image and store the expected text in session
    text = generate_captcha_image()
    session["captcha_text"] = text
    session["captcha_ts"] = int(time.time())
    # retrieve last generated image bytes from captcha module
    from captcha import last_image_bytes

    img = last_image_bytes()
    if img:
        # rate limit captcha image generation to avoid abuse
        if not rate_limit("captcha_img", limit=60, window_seconds=60):
            return ("Too Many Requests", 429)
        return send_file(io.BytesIO(img), mimetype="image/png")
    return ("", 404)


@main_bp.route("/captcha_audio")
def captcha_audio():
    # If no captcha in session, regenerate
    text = session.get("captcha_text") or generate_captcha_image()
    session["captcha_text"] = text
    wav_bytes = generate_captcha_audio(text)
    return send_file(io.BytesIO(wav_bytes), mimetype="audio/wav")


@main_bp.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("login"))

        # Validate input data
        validated_data, validation_errors = validate_request(LoginSchema, request.form)
        if validation_errors:
            for field, messages in validation_errors.items():
                if isinstance(messages, list):
                    flash(f"{field}: {'; '.join(messages)}", "error")
                else:
                    flash(f"{field}: {messages}", "error")
            return redirect(url_for("login"))

        # Rate limit login attempts per IP
        if not rate_limit("login_post", limit=10, window_seconds=300):
            flash("Too many login attempts. Please try again later.", "error")
            return redirect(url_for("login"))

        email = validated_data["email"].lower().strip()
        password = validated_data["password"]
        captcha = validated_data.get("captcha", "")

        # captcha verify (if present and not in testing mode)
        if not app.config.get("TESTING", False):
            # captcha expiry: 3 minutes
            ts = session.get("captcha_ts")
            if not ts or (int(time.time()) - int(ts) > 180):
                flash("Captcha expired. Please refresh and try again.", "error")
                return redirect(url_for("login"))
            if session.get("captcha_text") != captcha:
                flash("Invalid captcha", "error")
                return redirect(url_for("login"))
        # captcha verify (if present and not in testing mode)
        if not app.config.get("TESTING", False):
            # captcha expiry: 3 minutes
            ts = session.get("captcha_ts")
            if not ts or (int(time.time()) - int(ts) > 180):
                flash("Captcha expired. Please refresh and try again.", "error")
                return redirect(url_for("login"))
            if session.get("captcha_text") != captcha:
                flash("Invalid captcha", "error")
                return redirect(url_for("login"))
        user = User.query.filter_by(email=email).first()
        if user and user.check_password(password):
            # Check if account is locked
            if user.is_account_locked():
                flash(
                    "Account is temporarily locked due to too many failed login attempts. "
                    "Please try again later.",
                    "error",
                )
                log_security_event(
                    event_type="login_blocked",
                    description=f"Login blocked for locked account: {email}",
                    user_id=user.id,
                    ip_address=request.remote_addr,
                )
                return redirect(url_for("login"))

            # Check if 2FA is enabled
            if user.totp_enabled:
                # Store user ID in session temporarily and redirect to 2FA verification
                session["pending_2fa_user_id"] = user.id
                session["pending_2fa_email"] = email
                return redirect(url_for("verify_2fa"))

            # No 2FA required, proceed with login
            session["user_id"] = user.id
            user.record_login_attempt(success=True)

            # Create session tracking record
            import secrets

            session_token = secrets.token_urlsafe(32)
            session["session_token"] = session_token

            # Lazy import to avoid circular dependency
            from models_extended import UserActivity, UserSession

            user_session = UserSession(
                user_id=user.id,
                session_token=session_token,
                ip_address=request.remote_addr,
                user_agent=request.headers.get("User-Agent", ""),
                expires_at=datetime.now(timezone.utc) + timedelta(days=30),
            )
            db.session.add(user_session)

            db.session.add(
                UserActivity(
                    user_id=user.id,
                    activity_type="login",
                    ip_address=request.remote_addr,
                    user_agent=request.headers.get("User-Agent", ""),
                    details=json.dumps({"email": email}),
                )
            )

            db.session.commit()

            # Log security event
            log_security_event(
                event_type="login_success",
                description=f"User login successful: {email}",
                user_id=user.id,
                ip_address=request.remote_addr,
            )

            # clear captcha on success
            session.pop("captcha_text", None)
            session.pop("captcha_ts", None)
            flash("Logged in", "success")
            return redirect(url_for("dashboard"))
        else:
            # Failed login - record attempt
            if user:
                user.record_login_attempt(success=False)
                db.session.commit()

            # Log failed login attempt
            log_security_event(
                event_type="login_failed",
                description=f"Failed login attempt for: {email}",
                user_id=user.id if user else None,
                ip_address=request.remote_addr,
            )
            flash("Invalid credentials", "error")
            return redirect(url_for("login"))
    return render_template("login.html")


@main_bp.route("/verify-2fa", methods=["GET", "POST"])
def verify_2fa():
    """Verify two-factor authentication code."""
    user_id = session.get("pending_2fa_user_id")
    email = session.get("pending_2fa_email")

    if not user_id or not email:
        flash("Session expired. Please log in again.", "error")
        return redirect(url_for("login"))

    user = db.session.get(User, user_id)
    if not user or not user.totp_enabled:
        session.pop("pending_2fa_user_id", None)
        session.pop("pending_2fa_email", None)
        flash("Two-factor authentication not required.", "error")
        return redirect(url_for("login"))

    if request.method == "POST":
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("verify_2fa"))

        code = request.form.get("code", "").strip()
        backup_code = request.form.get("backup_code", "").strip()

        # Verify TOTP code or backup code
        code_valid = False
        if code and user.verify_totp(code):
            code_valid = True
        elif backup_code and user.use_backup_code(backup_code):
            code_valid = True
            flash("Backup code used. Please generate new backup codes.", "warning")

        if code_valid:
            # Complete login process
            session["user_id"] = user.id
            user.record_login_attempt(success=True)
            session.pop("pending_2fa_user_id", None)
            session.pop("pending_2fa_email", None)

            # Create session tracking record
            import secrets

            session_token = secrets.token_urlsafe(32)
            session["session_token"] = session_token

            # Lazy import to avoid circular dependency
            from models_extended import UserActivity, UserSession

            user_session = UserSession(
                user_id=user.id,
                session_token=session_token,
                ip_address=request.remote_addr,
                user_agent=request.headers.get("User-Agent", ""),
                expires_at=datetime.now(timezone.utc) + timedelta(days=30),
            )
            db.session.add(user_session)

            db.session.add(
                UserActivity(
                    user_id=user.id,
                    activity_type="login_2fa",
                    ip_address=request.remote_addr,
                    user_agent=request.headers.get("User-Agent", ""),
                    details=json.dumps(
                        {"email": email, "method": "backup_code" if backup_code else "totp"}
                    ),
                )
            )

            db.session.commit()

            # Log security event
            log_security_event(
                event_type="login_2fa_success",
                description=f"2FA verification successful for: {email}",
                user_id=user.id,
                ip_address=request.remote_addr,
            )

            flash("Logged in successfully", "success")
            return redirect(url_for("dashboard"))
        else:
            # Record failed 2FA attempt
            user.record_login_attempt(success=False)
            db.session.commit()

            log_security_event(
                event_type="login_2fa_failed",
                description=f"2FA verification failed for: {email}",
                user_id=user.id,
                ip_address=request.remote_addr,
            )

            flash("Invalid verification code", "error")
            return redirect(url_for("verify_2fa"))

    return render_template("verify_2fa.html", email=email)


@main_bp.route("/logout", methods=["GET", "POST"])
def logout():
    """Logout the current user and deactivate session."""
    user_id = session.get("user_id")
    session_token = session.get("session_token")

    if user_id and session_token:
        # Lazy import to avoid circular dependency
        from models_extended import UserActivity, UserSession

        # Deactivate the session in the database
        user_session = UserSession.query.filter_by(
            user_id=user_id, session_token=session_token, is_active=True
        ).first()

        if user_session:
            user_session.is_active = False
            db.session.commit()

        # Log the logout activity
        db.session.add(
            UserActivity(
                user_id=user_id,
                activity_type="logout",
                ip_address=request.remote_addr,
                user_agent=request.headers.get("User-Agent", ""),
            )
        )
        db.session.commit()

    # Clear the session
    session.clear()
    flash("Logged out successfully", "info")
    return redirect(url_for("index"))


@main_bp.route("/forgot", methods=["GET", "POST"])
def forgot():
    if request.method == "POST":
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("forgot"))
        # Rate limit forgot requests per IP
        if not rate_limit("forgot_post", limit=5, window_seconds=600):
            flash("Too many reset requests. Please try again later.", "error")
            return redirect(url_for("forgot"))
        # Captcha validation (skip in TESTING mode)
        captcha = request.form.get("captcha", "")
        if not app.config.get("TESTING", False):
            ts = session.get("captcha_ts")
            if not ts or (int(time.time()) - int(ts) > 180):
                flash("Captcha expired. Please refresh and try again.", "error")
                return redirect(url_for("forgot"))
            if session.get("captcha_text") != captcha:
                flash("Invalid captcha", "error")
                return redirect(url_for("forgot"))
        email = request.form.get("email", "").lower().strip()
        user = User.query.filter_by(email=email).first()
        if not user:
            flash(
                "If this email exists in our system, a local reset link will be shown.",
                "info",
            )
            return redirect(url_for("forgot"))
        # create local reset token and show to user (no email sending)
        token = secrets.token_urlsafe(32)
        user.reset_token = token
        db.session.commit()
        # clear captcha on success
        session.pop("captcha_text", None)
        session.pop("captcha_ts", None)
        # Display the token / local link so the admin/user can use it locally
        reset_link = url_for("reset_password", token=token, _external=True)
        return render_template("forgot_local.html", reset_link=reset_link, token=token)
    return render_template("forgot.html")


@main_bp.route("/reset/<token>", methods=["GET", "POST"])
def reset_password(token):
    user = User.query.filter_by(reset_token=token).first()
    if not user:
        flash("Invalid or expired token", "error")
        return redirect(url_for("forgot"))
    if request.method == "POST":
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("reset_password", token=token))
        # Rate limit reset password attempts per IP
        if not rate_limit("reset_post", limit=10, window_seconds=600):
            flash("Too many reset attempts. Please try again later.", "error")
            return redirect(url_for("reset_password", token=token))
        captcha = request.form.get("captcha", "")
        # captcha verify (if not in testing mode)
        if not app.config.get("TESTING", False):
            ts = session.get("captcha_ts")
            if not ts or (int(time.time()) - int(ts) > 180):
                flash("Captcha expired. Please refresh and try again.", "error")
                return redirect(url_for("reset_password", token=token))
            if session.get("captcha_text") != captcha:
                flash("Invalid captcha", "error")
                return redirect(url_for("reset_password", token=token))
        password = request.form.get("password", "")
        import re

        if (
            len(password) < 8
            or not re.search(r"[A-Z]", password)
            or not re.search(r"[a-z]", password)
            or not re.search(r"\d", password)
            or not re.search(r"[^A-Za-z0-9]", password)
        ):
            flash("Password does not meet complexity requirements", "error")
            return redirect(url_for("reset_password", token=token))
        user.set_password(password)
        user.reset_token = None
        db.session.commit()
        # clear captcha on success
        session.pop("captcha_text", None)
        session.pop("captcha_ts", None)
        flash("Password reset successful", "success")
        return redirect(url_for("login"))
    return render_template("reset.html", token=token)


@main_bp.route("/dashboard")
def dashboard():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    return render_template("dashboard.html", user=user, config=config)


@main_bp.route("/profile", methods=["GET", "POST"])
def profile():
    """User profile management."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user:
        return redirect(url_for("login"))

    if request.method == "POST":
        # CSRF check
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("profile"))

        # Handle avatar upload
        if "avatar" in request.files:
            file = request.files["avatar"]
            if file and file.filename:
                # Validate file type
                if not file.filename.lower().endswith((".png", ".jpg", ".jpeg", ".gif")):
                    flash("Invalid file type. Only PNG, JPG, JPEG, and GIF are allowed.", "error")
                    return redirect(url_for("profile"))

                # Process and save avatar
                try:
                    # Create avatars directory if it doesn't exist
                    avatar_dir = os.path.join(app.root_path, "static", "avatars")
                    os.makedirs(avatar_dir, exist_ok=True)

                    # Generate secure filename
                    filename = secure_filename(f"{user.id}_{secrets.token_hex(8)}.png")
                    filepath = os.path.join(avatar_dir, filename)

                    # Process image with PIL
                    image = Image.open(file)
                    # Convert to RGB if necessary (for JPEG compatibility)
                    if image.mode in ("RGBA", "P"):
                        image = image.convert("RGB")
                    # Resize to 200x200 max while maintaining aspect ratio
                    image.thumbnail((200, 200), Image.Resampling.LANCZOS)
                    # Create square image with white background
                    square_image = ImageOps.pad(image, (200, 200), color="white")
                    # Save as PNG
                    square_image.save(filepath, "PNG")

                    # Remove old avatar if exists
                    if user.avatar:
                        old_path = os.path.join(avatar_dir, user.avatar)
                        if os.path.exists(old_path):
                            os.remove(old_path)

                    # Update user avatar
                    user.avatar = filename

                except Exception as e:
                    flash(f"Error processing avatar: {str(e)}", "error")
                    return redirect(url_for("profile"))

        # Update profile
        first_name = request.form.get("first_name", "").strip()
        last_name = request.form.get("last_name", "").strip()
        bio = request.form.get("bio", "").strip()[:500]  # Limit bio to 500 chars

        if first_name:
            user.first_name = first_name
        if last_name:
            user.last_name = last_name
        user.bio = bio

        try:
            db.session.commit()
            flash("Profile updated successfully", "success")
        except Exception as e:
            db.session.rollback()
            flash(f"Error updating profile: {str(e)}", "error")

        return redirect(url_for("profile"))

    return render_template("profile.html", user=user)


@main_bp.route("/profile/avatar/remove", methods=["POST"])
def remove_avatar():
    """Remove user avatar."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user:
        return redirect(url_for("login"))

    # CSRF check
    try:
        verify_csrf()
    except Exception:
        flash("Invalid CSRF token", "error")
        return redirect(url_for("profile"))

    # Remove avatar file if exists
    if user.avatar:
        avatar_path = os.path.join(app.root_path, "static", "avatars", user.avatar)
        if os.path.exists(avatar_path):
            try:
                os.remove(avatar_path)
            except Exception:
                pass  # Ignore file removal errors

        user.avatar = None
        try:
            db.session.commit()
            flash("Avatar removed successfully", "success")
        except Exception as e:
            db.session.rollback()
            flash(f"Error removing avatar: {str(e)}", "error")

    return redirect(url_for("profile"))


@main_bp.route("/analytics", methods=["GET"])
def analytics_dashboard():
    """Advanced analytics dashboard with real-time metrics and insights."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    if not user:
        return redirect(url_for("login"))

    # Check RBAC permission for analytics access
    from rbac import has_permission

    if not has_permission(user, "monitor.view_system"):
        flash("Analytics access requires appropriate permissions", "error")
        return redirect(url_for("dashboard"))

    return render_template("analytics.html", user=user)


@main_bp.route("/api/analytics/metrics", methods=["GET"])
def get_analytics_metrics():
    """API endpoint for analytics data."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        # Get time range (default last 24 hours)
        hours = int(request.args.get("hours", 24))

        # Try to get from cache first
        cache_svc = get_cache_service()
        cache_key = f"analytics_metrics:{hours}"

        cached_data = cache_svc.get(cache_key)
        if cached_data:
            return jsonify(cached_data)

        since = datetime.now(timezone.utc) - timedelta(hours=hours)

        from monitoring_system import ServerMetrics

        # Server performance metrics (cache for 5 minutes)
        performance_data = (
            db.session.query(
                ServerMetrics.timestamp,
                db.func.avg(ServerMetrics.cpu_usage).label("cpu_avg"),
                db.func.avg(ServerMetrics.memory_percentage).label("memory_avg"),
                db.func.avg(ServerMetrics.player_count).label("players_avg"),
            )
            .filter(ServerMetrics.timestamp >= since)
            .group_by(db.func.strftime("%Y-%m-%d %H", ServerMetrics.timestamp))
            .order_by(ServerMetrics.timestamp)
            .all()
        )

        # Player activity over time
        player_activity = []
        for row in performance_data:
            player_activity.append(
                {
                    "time": row.timestamp.strftime("%H:00"),
                    "cpu": round(row.cpu_avg or 0, 1),
                    "memory": round(row.memory_avg or 0, 1),
                    "players": int(row.players_avg or 0),
                }
            )

        # Current server status (cache for 1 minute - more volatile)
        current_metrics = (
            db.session.query(ServerMetrics)
            .filter(ServerMetrics.timestamp >= datetime.now(timezone.utc) - timedelta(minutes=5))
            .order_by(ServerMetrics.timestamp.desc())
            .first()
        )

        current_status = {
            "cpu_usage": round(current_metrics.cpu_usage or 0, 1) if current_metrics else 0,
            "memory_usage": round(current_metrics.memory_percentage or 0, 1)
            if current_metrics
            else 0,
            "player_count": current_metrics.player_count or 0 if current_metrics else 0,
            "active_servers": db.session.query(Server).count(),
        }

        # Top maps by player count (cache for 10 minutes)
        top_maps = (
            db.session.query(
                ServerMetrics.map_name, db.func.avg(ServerMetrics.player_count).label("avg_players")
            )
            .filter(ServerMetrics.timestamp >= since, ServerMetrics.map_name.isnot(None))
            .group_by(ServerMetrics.map_name)
            .order_by(db.desc("avg_players"))
            .limit(10)
            .all()
        )

        map_data = [{"map": row.map_name, "players": round(row.avg_players, 1)} for row in top_maps]

        # Geographic distribution (mock data for now - would need IP geolocation)
        geo_data = [
            {"country": "United States", "players": 45},
            {"country": "Germany", "players": 23},
            {"country": "United Kingdom", "players": 18},
            {"country": "Canada", "players": 12},
            {"country": "Australia", "players": 8},
        ]

        # Player retention analysis (cache for 15 minutes - expensive calculation)
        retention_data = []
        for days_ago in range(7, 0, -1):
            date_start = (datetime.now(timezone.utc) - timedelta(days=days_ago)).date()
            date_end = (datetime.now(timezone.utc) - timedelta(days=days_ago - 1)).date()

            players_day1 = (
                db.session.query(db.func.count(db.distinct(ServerMetrics.player_count)))
                .filter(db.func.date(ServerMetrics.timestamp) == date_start)
                .scalar()
                or 0
            )

            players_day2 = (
                db.session.query(db.func.count(db.distinct(ServerMetrics.player_count)))
                .filter(db.func.date(ServerMetrics.timestamp) == date_end)
                .scalar()
                or 0
            )

            retention_rate = (players_day2 / players_day1 * 100) if players_day1 > 0 else 0
            retention_data.append(
                {"date": date_start.strftime("%m/%d"), "retention": round(retention_rate, 1)}
            )

        # Server uptime tracking (cache for 15 minutes)
        uptime_data = []
        total_servers = db.session.query(Server).count()
        for days_ago in range(7, 0, -1):
            check_date = (datetime.now(timezone.utc) - timedelta(days=days_ago)).date()
            online_servers = (
                db.session.query(db.func.count(db.distinct(ServerMetrics.server_id)))
                .filter(db.func.date(ServerMetrics.timestamp) == check_date)
                .scalar()
                or 0
            )

            uptime_percentage = (online_servers / total_servers * 100) if total_servers > 0 else 0
            uptime_data.append(
                {"date": check_date.strftime("%m/%d"), "uptime": round(uptime_percentage, 1)}
            )

        result_data = {
            "performance": player_activity,
            "current_status": current_status,
            "top_maps": map_data,
            "geographic": geo_data,
            "retention": retention_data,
            "uptime": uptime_data,
            "time_range": f"Last {hours} hours",
        }

        # Cache the result for 5 minutes
        cache_svc.set(cache_key, result_data, timeout=300)

        return jsonify(result_data)

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_bp.route("/api/analytics/export", methods=["GET"])
def export_analytics_csv():
    """Export analytics data as CSV."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return redirect(url_for("dashboard"))

    try:
        hours = int(request.args.get("hours", 24))
        since = datetime.now(timezone.utc) - timedelta(hours=hours)

        from monitoring_system import ServerMetrics

        # Get performance data
        performance_data = (
            db.session.query(
                ServerMetrics.timestamp,
                db.func.avg(ServerMetrics.cpu_usage).label("cpu_avg"),
                db.func.avg(ServerMetrics.memory_percentage).label("memory_avg"),
                db.func.avg(ServerMetrics.player_count).label("players_avg"),
            )
            .filter(ServerMetrics.timestamp >= since)
            .group_by(db.func.strftime("%Y-%m-%d %H", ServerMetrics.timestamp))
            .order_by(ServerMetrics.timestamp)
            .all()
        )

        # Create CSV
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(["Timestamp", "CPU Usage (%)", "Memory Usage (%)", "Player Count"])

        for row in performance_data:
            writer.writerow(
                [
                    row.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
                    round(row.cpu_avg or 0, 1),
                    round(row.memory_avg or 0, 1),
                    int(row.players_avg or 0),
                ]
            )

        output.seek(0)
        return Response(
            output.getvalue(),
            mimetype="text/csv",
            headers={"Content-Disposition": f"attachment; filename=analytics_{hours}h.csv"},
        )

    except Exception as e:
        return jsonify({"error": str(e)}), 500


# ============================================================================
# REST API ENDPOINTS
# ============================================================================


@main_bp.route("/api/servers", methods=["GET"])
def api_get_servers():
    """Get list of servers accessible to the authenticated user."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user:
        return jsonify({"error": "User not found"}), 404

    # Get servers user can access
    servers = Server.query.filter((Server.owner_id == uid) | (Server.users.any(user_id=uid))).all()

    server_data = []
    for server in servers:
        server_data.append(
            {
                "id": server.id,
                "name": server.name,
                "host": server.host,
                "port": server.port,
                "game_type": server.game_type,
                "status": "online" if server.is_online() else "offline",
                "player_count": server.get_player_count()
                if hasattr(server, "get_player_count")
                else 0,
                "max_players": server.max_players or 32,
                "map": server.current_map,
                "created_at": server.created_at.isoformat() if server.created_at else None,
                "updated_at": server.updated_at.isoformat() if server.updated_at else None,
            }
        )

    return jsonify({"servers": server_data, "total": len(server_data)})


@main_bp.route("/api/servers/<int:server_id>", methods=["GET"])
def api_get_server(server_id):
    """Get detailed information about a specific server."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user:
        return jsonify({"error": "User not found"}), 404

    server = db.session.get(Server, server_id)
    if not server:
        return jsonify({"error": "Server not found"}), 404

    # Check if user has access to this server
    if server.owner_id != uid and not server.users.filter_by(user_id=uid).first():
        return jsonify({"error": "Access denied"}), 403

    from monitoring_system import ServerMetrics

    # Get recent metrics
    recent_metrics = (
        ServerMetrics.query.filter_by(server_id=server_id)
        .order_by(ServerMetrics.timestamp.desc())
        .limit(10)
        .all()
    )

    metrics_data = []
    for metric in recent_metrics:
        metrics_data.append(
            {
                "timestamp": metric.timestamp.isoformat(),
                "cpu_usage": metric.cpu_usage,
                "memory_percentage": metric.memory_percentage,
                "player_count": metric.player_count,
                "map_name": metric.map_name,
            }
        )

    server_data = {
        "id": server.id,
        "name": server.name,
        "host": server.host,
        "port": server.port,
        "game_type": server.game_type,
        "status": "online" if server.is_online() else "offline",
        "player_count": server.get_player_count() if hasattr(server, "get_player_count") else 0,
        "max_players": server.max_players or 32,
        "map": server.current_map,
        "config": json.loads(server.raw_config) if server.raw_config else {},
        "recent_metrics": metrics_data,
        "created_at": server.created_at.isoformat() if server.created_at else None,
        "updated_at": server.updated_at.isoformat() if server.updated_at else None,
    }

    return jsonify(server_data)


@main_bp.route("/api/servers/<int:server_id>/status", methods=["GET"])
def api_get_server_status(server_id):
    """Get real-time status of a server."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user:
        return jsonify({"error": "User not found"}), 404

    server = db.session.get(Server, server_id)
    if not server:
        return jsonify({"error": "Server not found"}), 404

    # Check if user has access to this server
    if server.owner_id != uid and not server.users.filter_by(user_id=uid).first():
        return jsonify({"error": "Access denied"}), 403

    try:
        # Get current status
        is_online = server.is_online() if hasattr(server, "is_online") else False
        player_count = server.get_player_count() if hasattr(server, "get_player_count") else 0

        status_data = {
            "server_id": server_id,
            "online": is_online,
            "player_count": player_count,
            "max_players": server.max_players or 32,
            "current_map": server.current_map,
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }

        return jsonify(status_data)

    except Exception as e:
        return jsonify({"error": f"Failed to get server status: {str(e)}"}), 500


@main_bp.route("/api/servers/<int:server_id>/command", methods=["POST"])
def api_send_command(server_id):
    """Send RCON command to server."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user:
        return jsonify({"error": "User not found"}), 404

    server = db.session.get(Server, server_id)
    if not server:
        return jsonify({"error": "Server not found"}), 404

    # Check if user has access to this server
    if server.owner_id != uid and not server.users.filter_by(user_id=uid).first():
        return jsonify({"error": "Access denied"}), 403

    data = request.get_json()
    if not data or "command" not in data:
        return jsonify({"error": "Command is required"}), 400

    command = data["command"].strip()
    if not command:
        return jsonify({"error": "Command cannot be empty"}), 400

    try:
        # Send RCON command
        rcon = ETLegacyRcon.from_server(server)
        response = rcon.send_command(command)

        # Log the command
        from models_extended import RconCommandHistory
        command_log = RconCommandHistory(
            server_id=server_id,
            user_id=uid,
            command=command,
            response=response,
            timestamp=datetime.now(timezone.utc),
        )
        db.session.add(command_log)
        db.session.commit()

        return jsonify(
            {
                "success": True,
                "command": command,
                "response": response,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }
        )

    except Exception as e:
        return jsonify({"error": f"Failed to send command: {str(e)}"}), 500


@main_bp.route("/api/servers/<int:server_id>/players", methods=["GET"])
def api_get_server_players(server_id):
    """Get list of players on a server."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user:
        return jsonify({"error": "User not found"}), 404

    server = db.session.get(Server, server_id)
    if not server:
        return jsonify({"error": "Server not found"}), 404

    # Check if user has access to this server
    if server.owner_id != uid and not server.users.filter_by(user_id=uid).first():
        return jsonify({"error": "Access denied"}), 403

    try:
        # Get player list (this would need to be implemented in the server model)
        players = server.get_players() if hasattr(server, "get_players") else []

        player_data = []
        for player in players:
            player_data.append(
                {
                    "name": player.get("name", "Unknown"),
                    "score": player.get("score", 0),
                    "ping": player.get("ping", 0),
                    "team": player.get("team", "spectator"),
                }
            )

        return jsonify(
            {
                "server_id": server_id,
                "players": player_data,
                "count": len(player_data),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }
        )

    except Exception as e:
        return jsonify({"error": f"Failed to get player list: {str(e)}"}), 500


@main_bp.route("/api/webhooks", methods=["POST"])
def api_webhook():
    """Handle incoming webhooks from external services."""
    # Basic webhook endpoint - can be extended for specific integrations
    data = request.get_json()

    if not data:
        return jsonify({"error": "Invalid webhook data"}), 400

    # Log webhook for debugging
    print(f"Webhook received: {data}")

    # Process webhook based on type
    webhook_type = data.get("type", "unknown")

    if webhook_type == "server_status":
        # Handle server status updates
        server_id = data.get("server_id")
        status = data.get("status")

        if server_id and status:
            # Update server status in database
            server = db.session.get(Server, server_id)
            if server:
                # This could trigger notifications, etc.
                print(f"Server {server_id} status update: {status}")

    elif webhook_type == "player_event":
        # Handle player join/leave events
        server_id = data.get("server_id")
        player_name = data.get("player_name")
        event_type = data.get("event")  # 'join' or 'leave'

        if server_id and player_name and event_type:
            print(f"Player {player_name} {event_type}ed server {server_id}")

    return jsonify({"status": "received"}), 200


# ============================================================================
# API AUTHENTICATION
# ============================================================================


def authenticate_api_token():
    """Authenticate user via API token."""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        return None

    token = auth_header.replace("Bearer ", "")

    # Find user with this token
    user = User.query.filter_by(api_token=token).first()
    if user and user.validate_api_token(token):
        db.session.commit()  # Save last used time
        return user

    return None


def require_api_auth(f):
    """Decorator to require API authentication."""

    @wraps(f)
    def decorated_function(*args, **kwargs):
        user = authenticate_api_token()
        if not user:
            return jsonify({"error": "Invalid or missing API token"}), 401

        # Add user to request context
        request.api_user = user
        return f(*args, **kwargs)

    return decorated_function


# ============================================================================
# API TOKEN MANAGEMENT ROUTES
# ============================================================================


@main_bp.route("/api/tokens", methods=["GET"])
def api_get_tokens():
    """Get user's API tokens."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user:
        return redirect(url_for("login"))

    tokens = []
    if user.api_token:
        tokens.append(
            {
                "token": user.api_token[:20] + "...",  # Show only first 20 chars
                "created_at": user.api_token_created.isoformat()
                if user.api_token_created
                else None,
                "last_used": user.api_token_last_used.isoformat()
                if user.api_token_last_used
                else None,
            }
        )

    return render_template("api_tokens.html", user=user, tokens=tokens)


@main_bp.route("/api/tokens/generate", methods=["POST"])
def api_generate_token():
    """Generate a new API token."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user:
        return redirect(url_for("login"))

    # Revoke existing token
    user.revoke_api_token()

    # Generate new token
    user.generate_api_token()
    db.session.commit()

    flash("New API token generated successfully", "success")
    return redirect(url_for("api_get_tokens"))


@main_bp.route("/api/tokens/revoke", methods=["POST"])
def api_revoke_token():
    """Revoke the current API token."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user:
        return redirect(url_for("login"))

    user.revoke_api_token()
    db.session.commit()

    flash("API token revoked successfully", "success")
    return redirect(url_for("api_get_tokens"))


# ============================================================================
# RATE LIMITING
# ============================================================================

import time
from functools import wraps

# Simple in-memory rate limiting (for production, use Redis)
rate_limits = {}


def rate_limit_decorator(max_calls=100, time_window=60):
    """Rate limiting decorator."""

    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # Get client identifier (IP address for now)
            client_ip = request.remote_addr
            key = f"{client_ip}:{f.__name__}"

            current_time = time.time()
            if key not in rate_limits:
                rate_limits[key] = []

            # Clean old entries
            rate_limits[key] = [t for t in rate_limits[key] if current_time - t < time_window]

            # Check rate limit
            if len(rate_limits[key]) >= max_calls:
                return jsonify({"error": "Rate limit exceeded"}), 429

            # Add current request
            rate_limits[key].append(current_time)

            return f(*args, **kwargs)

        return decorated_function

    return decorator


# ============================================================================
# REST API ENDPOINTS (Token Authenticated)
# ============================================================================


@main_bp.route("/api/v1/servers", methods=["GET"])
@require_api_auth
@rate_limit_decorator(max_calls=60, time_window=60)  # 60 requests per minute
def api_v1_get_servers():
    """Get list of servers accessible to the authenticated user (API version)."""
    user = request.api_user

    # Get servers user can access
    servers = Server.query.filter(
        (Server.owner_id == user.id) | (Server.users.any(user_id=user.id))
    ).all()

    server_data = []
    for server in servers:
        server_data.append(
            {
                "id": server.id,
                "name": server.name,
                "host": server.host,
                "port": server.port,
                "game_type": server.game_type,
                "status": "online" if server.is_online() else "offline",
                "player_count": server.get_player_count()
                if hasattr(server, "get_player_count")
                else 0,
                "max_players": server.max_players or 32,
                "map": server.current_map,
                "created_at": server.created_at.isoformat() if server.created_at else None,
                "updated_at": server.updated_at.isoformat() if server.updated_at else None,
            }
        )

    return jsonify({"servers": server_data, "total": len(server_data), "api_version": "v1"})


@main_bp.route("/api/v1/servers/<int:server_id>", methods=["GET"])
@require_api_auth
@rate_limit_decorator(max_calls=120, time_window=60)  # 120 requests per minute
def api_v1_get_server(server_id):
    """Get detailed information about a specific server (API version)."""
    user = request.api_user

    server = db.session.get(Server, server_id)
    if not server:
        return jsonify({"error": "Server not found"}), 404

    # Check if user has access to this server
    if server.owner_id != user.id and not server.users.filter_by(user_id=user.id).first():
        return jsonify({"error": "Access denied"}), 403

    server_data = {
        "id": server.id,
        "name": server.name,
        "host": server.host,
        "port": server.port,
        "game_type": server.game_type,
        "status": "online" if server.is_online() else "offline",
        "player_count": server.get_player_count() if hasattr(server, "get_player_count") else 0,
        "max_players": server.max_players or 32,
        "map": server.current_map,
        "created_at": server.created_at.isoformat() if server.created_at else None,
        "updated_at": server.updated_at.isoformat() if server.updated_at else None,
    }

    return jsonify(server_data)


@main_bp.route("/api/v1/servers/<int:server_id>/command", methods=["POST"])
@require_api_auth
@rate_limit_decorator(max_calls=30, time_window=60)  # 30 commands per minute
def api_v1_send_command(server_id):
    """Send RCON command to server (API version)."""
    user = request.api_user

    server = db.session.get(Server, server_id)
    if not server:
        return jsonify({"error": "Server not found"}), 404

    # Check if user has access to this server
    if server.owner_id != user.id and not server.users.filter_by(user_id=user.id).first():
        return jsonify({"error": "Access denied"}), 403

    data = request.get_json()
    if not data or "command" not in data:
        return jsonify({"error": "Command is required"}), 400

    command = data["command"].strip()
    if not command:
        return jsonify({"error": "Command cannot be empty"}), 400

    try:
        # Send RCON command
        rcon = ETLegacyRcon.from_server(server)
        response = rcon.send_command(command)

        # Log the command
        from models_extended import RconCommandHistory
        command_log = RconCommandHistory(
            server_id=server_id,
            user_id=user.id,
            command=command,
            response=response,
            timestamp=datetime.now(timezone.utc),
        )
        db.session.add(command_log)
        db.session.commit()

        return jsonify(
            {
                "success": True,
                "command": command,
                "response": response,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }
        )

    except Exception as e:
        return jsonify({"error": f"Failed to send command: {str(e)}"}), 500


@main_bp.route("/api/v1/webhooks", methods=["POST"])
@rate_limit_decorator(max_calls=1000, time_window=60)  # Higher limit for webhooks
def api_v1_webhook():
    """Handle incoming webhooks from external services (API version)."""
    # For webhooks, we might want to use a different authentication method
    # or allow anonymous webhooks with validation

    data = request.get_json()

    if not data:
        return jsonify({"error": "Invalid webhook data"}), 400

    # Log webhook for debugging
    print(f"Webhook received: {data}")

    # Process webhook based on type
    webhook_type = data.get("type", "unknown")

    if webhook_type == "server_status":
        # Handle server status updates
        server_id = data.get("server_id")
        status = data.get("status")

        if server_id and status:
            # Update server status in database
            server = db.session.get(Server, server_id)
            if server:
                # This could trigger notifications, etc.
                print(f"Server {server_id} status update: {status}")

    elif webhook_type == "player_event":
        # Handle player join/leave events
        server_id = data.get("server_id")
        player_name = data.get("player_name")
        event_type = data.get("event")  # 'join' or 'leave'

        if server_id and player_name and event_type:
            print(f"Player {player_name} {event_type}ed server {server_id}")

    return jsonify({"status": "received"}), 200


@main_bp.route("/api/v1/health", methods=["GET"])
@rate_limit_decorator(max_calls=1000, time_window=60)  # High limit for health checks
def api_v1_health_check():
    """API health check endpoint (API version)."""
    return jsonify(
        {
            "status": "healthy",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "version": "1.0.0",
            "api_version": "v1",
        }
    )


@main_bp.route("/api/docs", methods=["GET"])
def api_docs():
    """API documentation page."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user:
        return redirect(url_for("login"))

    return render_template("api_docs.html", user=user)


@main_bp.route("/api/openapi.json", methods=["GET"])
def api_openapi_spec():
    """OpenAPI/Swagger specification for the API."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user:
        return jsonify({"error": "User not found"}), 404

    # OpenAPI 3.0 specification
    openapi_spec = {
        "openapi": "3.0.3",
        "info": {
            "title": "Panel API",
            "description": "REST API for the Panel game server management system",
            "version": "1.0.0",
            "contact": {
                "name": "Panel Development Team"
            }
        },
        "servers": [
            {
                "url": request.host_url.rstrip('/'),
                "description": "Production server"
            }
        ],
        "security": [
            {
                "bearerAuth": []
            },
            {
                "sessionAuth": []
            }
        ],
        "components": {
            "securitySchemes": {
                "bearerAuth": {
                    "type": "http",
                    "scheme": "bearer",
                    "description": "API token authentication"
                },
                "sessionAuth": {
                    "type": "apiKey",
                    "in": "cookie",
                    "name": "session",
                    "description": "Session-based authentication"
                }
            },
            "schemas": {
                "Error": {
                    "type": "object",
                    "properties": {
                        "error": {
                            "type": "string",
                            "description": "Error message"
                        }
                    }
                },
                "Server": {
                    "type": "object",
                    "properties": {
                        "id": {"type": "integer", "description": "Server ID"},
                        "name": {"type": "string", "description": "Server name"},
                        "host": {"type": "string", "description": "Server host"},
                        "port": {"type": "integer", "description": "Server port"},
                        "game_type": {"type": "string", "description": "Game type"},
                        "status": {"type": "string", "enum": ["online", "offline"]},
                        "player_count": {"type": "integer", "description": "Current player count"},
                        "max_players": {"type": "integer", "description": "Maximum players"},
                        "map": {"type": "string", "description": "Current map"},
                        "created_at": {"type": "string", "format": "date-time"},
                        "updated_at": {"type": "string", "format": "date-time"}
                    }
                },
                "AnalyticsMetrics": {
                    "type": "object",
                    "properties": {
                        "performance": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "time": {"type": "string"},
                                    "cpu": {"type": "number"},
                                    "memory": {"type": "number"},
                                    "players": {"type": "integer"}
                                }
                            }
                        },
                        "current_status": {
                            "type": "object",
                            "properties": {
                                "cpu_usage": {"type": "number"},
                                "memory_usage": {"type": "number"},
                                "player_count": {"type": "integer"},
                                "active_servers": {"type": "integer"},
                            }
                        },
                        "top_maps": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "map": {"type": "string"},
                                    "players": {"type": "number"}
                                }
                            }
                        },
                        "geographic": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "country": {"type": "string"},
                                    "players": {"type": "integer"}
                                }
                            }
                        },
                        "retention": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "date": {"type": "string", "format": "date"},
                                    "retention": {"type": "number"}
                                }
                            }
                        },
                        "uptime": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "date": {"type": "string", "format": "date"},
                                    "uptime": {"type": "number"}
                                }
                            }
                        },
                        "time_range": {"type": "string"}
                    }
                }
            }
        },
        "paths": {
            "/api/v1/servers": {
                "get": {
                    "summary": "Get servers",
                    "description": "Retrieve list of servers accessible to the authenticated user",
                    "security": [{"bearerAuth": []}, {"sessionAuth": []}],
                    "responses": {
                        "200": {
                            "description": "List of servers",
                            "content": {
                                "application/json": {
                                    "schema": {
                                        "type": "object",
                                        "properties": {
                                            "servers": {
                                                "type": "array",
                                                "items": {"$ref": "#/components/schemas/Server"}
                                            },
                                            "total": {"type": "integer"}
                                        }
                                    }
                                }
                            }
                        },
                        "401": {
                            "description": "Authentication required",
                            "content": {
                                "application/json": {
                                    "schema": {"$ref": "#/components/schemas/Error"}
                                }
                            }
                        }
                    }
                }
            },
            "/api/analytics/metrics": {
                "get": {
                    "summary": "Get analytics metrics",
                    "description": "Retrieve analytics and performance metrics",
                    "security": [{"sessionAuth": []}],
                    "parameters": [
                        {
                            "name": "hours",
                            "in": "query",
                            "description": "Time range in hours (default: 24)",
                            "schema": {"type": "integer", "default": 24}
                        }
                    ],
                    "responses": {
                        "200": {
                            "description": "Analytics metrics",
                            "content": {
                                "application/json": {
                                    "schema": {"$ref": "#/components/schemas/AnalyticsMetrics"}
                                }
                            }
                        },
                        "403": {
                            "description": "Admin access required",
                            "content": {
                                "application/json": {
                                    "schema": {"$ref": "#/components/schemas/Error"}
                                }
                            }
                        }
                    }
                }
            },
            "/health": {
                "get": {
                    "summary": "Health check",
                    "description": "Basic health check for load balancers",
                    "responses": {
                        "200": {
                            "description": "Service is healthy",
                            "content": {
                                "application/json": {
                                    "schema": {
                                        "type": "object",
                                        "properties": {
                                            "status": {"type": "string"},
                                            "timestamp": {"type": "string", "format": "date-time"},
                                            "uptime_seconds": {"type": "integer"},
                                            "checks": {
                                                "type": "object",
                                                "properties": {
                                                    "database": {"type": "string"},
                                                    "redis": {"type": "string"},
                                                }
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                }
            },
            "/metrics": {
                "get": {
                    "summary": "Prometheus metrics",
                    "description": "Prometheus-compatible metrics for monitoring",
                    "security": [{"sessionAuth": []}],
                    "responses": {
                        "200": {
                            "description": "Metrics in Prometheus format",
                            "content": {
                                "text/plain": {
                                    "schema": {"type": "string"}
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return jsonify(openapi_spec)


@main_bp.route("/admin/rbac/init", methods=["POST"])
def admin_rbac_init():
    """Initialize the RBAC system with default permissions and roles."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        flash("RBAC initialization requires admin privileges", "error")
        return redirect(url_for("dashboard"))

    try:
        from rbac import initialize_rbac_system

        initialize_rbac_system()
        flash("RBAC system initialized successfully", "success")
    except Exception as e:
        flash(f"Failed to initialize RBAC system: {str(e)}", "error")

    return redirect(url_for("admin_rbac_roles"))


# ============================================================================
# BACKUP MANAGEMENT ROUTES
# ============================================================================


@main_bp.route("/backups", methods=["GET"])
def backup_dashboard():
    """Backup management dashboard."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user:
        return redirect(url_for("login"))

    # Check RBAC permission for backup access
    from rbac import has_permission

    if not has_permission(user, "admin.backup_restore"):
        flash("Backup access requires appropriate permissions", "error")
        return redirect(url_for("dashboard"))

    # Get backup statistics
    stats = backup_manager.get_backup_stats()

    # Get recent backups
    recent_backups = backup_manager.list_backups()

    return render_template("backups.html", user=user, stats=stats, recent_backups=recent_backups)


@main_bp.route("/api/backups/create/database", methods=["POST"])
def api_create_database_backup():
    """Create a database backup."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return redirect(url_for("dashboard"))

    try:
        name = request.form.get("name") or f"manual_db_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        backup_file = backup_manager.create_database_backup(name)

        if backup_file:
            return jsonify(
                {
                    "success": True,
                    "message": "Database backup created successfully",
                    "backup_file": backup_file,
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                }
            )
        else:
            return jsonify({"error": "Failed to create database backup"}), 500

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_bp.route("/api/backups/create/config", methods=["POST"])
def api_create_config_backup():
    """Create a configuration backup."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return redirect(url_for("dashboard"))

    try:
        name = (
            request.form.get("name") or f"manual_config_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        )
        config_files = request.form.get("files")
        if config_files:
            config_files = json.loads(config_files)
        else:
            config_files = None

        backup_file = backup_manager.create_config_backup(config_files, name)

        if backup_file:
            return jsonify(
                {
                    "success": True,
                    "message": "Configuration backup created successfully",
                    "backup_file": backup_file,
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                }
            )
        else:
            return jsonify({"error": "Failed to create configuration backup"}), 500

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_bp.route("/api/backups/create/server/<int:server_id>", methods=["POST"])
def api_create_server_backup(server_id):
    """Create a server configuration backup."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))

    user = db.session.get(User, uid)
    if not user:
        return redirect(url_for("login"))

    server = db.session.get(Server, server_id)
    if not server:
        return redirect(url_for("dashboard"))

    # Check if user has access to this server
    if server.owner_id != uid and not server.users.filter_by(user_id=uid).first():
        return redirect(url_for("dashboard"))

    try:
        name = (
            request.form.get("name")
            or f"server_{server_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        )

        # Get server data for backup
        server_data = {
            "id": server.id,
            "name": server.name,
            "host": server.host,
            "port": server.port,
            "rcon_password": server.rcon_password,
            "variables_json": server.variables_json,
            "raw_config": server.raw_config,
            "game_type": server.game_type,
            "max_players": server.max_players,
        }

        backup_file = backup_manager.create_server_backup(server_id, server_data, name)

        if backup_file:
            return jsonify(
                {
                    "success": True,
                    "message": "Server backup created successfully",
                    "backup_file": backup_file,
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                }
            )
        else:
            return jsonify({"error": "Failed to create server backup"}), 500

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_bp.route("/api/backups/list", methods=["GET"])
def api_list_backups():
    """List available backups."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        backup_type = request.args.get("type")
        backups = backup_manager.list_backups(backup_type)
        return jsonify(backups)

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_bp.route("/api/backups/restore/database", methods=["POST"])
def api_restore_database():
    """Restore database from backup."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        backup_file = request.form.get("backup_file")
        if not backup_file:
            return jsonify({"error": "Backup file is required"}), 400

        success = backup_manager.restore_database(backup_file)

        if success:
            return jsonify(
                {
                    "success": True,
                    "message": "Database restored successfully",
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                }
            )
        else:
            return jsonify({"error": "Failed to restore database"}), 500

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_bp.route("/api/backups/restore/config", methods=["POST"])
def api_restore_config():
    """Restore configuration from backup."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        backup_file = request.form.get("backup_file")
        if not backup_file:
            return jsonify({"error": "Backup file is required"}), 400

        restored_files = backup_manager.restore_config(backup_file)

        if restored_files:
            return jsonify(
                {
                    "success": True,
                    "message": f"Configuration restored successfully. "
                    f"Files: {', '.join(restored_files)}",
                    "restored_files": restored_files,
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                }
            )
        else:
            return jsonify({"error": "Failed to restore configuration"}), 500

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_bp.route("/api/backups/cleanup", methods=["POST"])
def api_cleanup_backups():
    """Clean up old backups."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        days_to_keep = int(request.form.get("days", 30))
        deleted_files = backup_manager.cleanup_old_backups(days_to_keep)

        return jsonify(
            {
                "success": True,
                "message": f"Cleaned up {len(deleted_files)} old backup files",
                "deleted_files": deleted_files,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }
        )

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_bp.route("/api/backups/download/<path:filename>", methods=["GET"])
def api_download_backup(filename):
    """Download a backup file."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not user or not user.is_system_admin():
        return jsonify({"error": "Admin access required"}), 403

    try:
        # Security check - ensure file is within backups directory
        backup_path = Path("backups") / filename
        if not backup_path.exists() or not backup_path.is_file():
            return jsonify({"error": "Backup file not found"}), 404

        # Ensure path is within backups directory
        if not str(backup_path.resolve()).startswith(str(Path("backups").resolve())):
            return jsonify({"error": "Access denied"}), 403

        return send_file(str(backup_path), as_attachment=True)

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_bp.route("/rcon", methods=["GET", "POST"])
def rcon_console():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)

    # Get all servers the user can access
    servers = Server.query.filter((Server.owner_id == uid) | (Server.users.any(user_id=uid))).all()

    # If no server specified, redirect to first available server
    server_id = request.args.get("server_id", type=int)
    if not server_id and servers:
        return redirect(url_for("rcon_console", server_id=servers[0].id))

    server = None
    if server_id:
        server = db.session.get(Server, server_id)
        if not server or not user_can_edit_server(user, server):
            flash("Server not found or access denied", "error")
            return redirect(url_for("dashboard"))

    output = None
    if request.method == "POST" and server:
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("rcon_console", server_id=server_id))
        cmd = request.form.get("command", "").strip()
        if cmd:
            from rcon_client import ETLegacyRcon

            # Check if server has connection details
            if not server.host or not server.port or not server.rcon_password:
                output = (
                    "Error: Server connection details not configured (host, port, RCON password)"
                )
            else:
                rc = ETLegacyRcon.from_server(server)
                try:
                    output = rc.send(cmd)
                except Exception as e:
                    output = f"Error: {e}"

    return render_template("rcon.html", output=output, servers=servers, current_server=server)


def is_system_admin_user(user):
    if not user or not user.email:
        return False
    return user.is_system_admin()


def is_server_admin_user(user):
    if not user or not user.email:
        return False
    return user.is_server_admin()


def is_server_mod_user(user):
    if not user or not user.email:
        return False
    return user.is_server_mod()


@main_bp.route("/health/detailed")
def detailed_health_check():
    """Detailed health check for admin monitoring."""
    uid = session.get("user_id")
    if not uid:
        return jsonify({"error": "Authentication required"}), 401

    user = db.session.get(User, uid)
    if not is_system_admin_user(user):
        return jsonify({"error": "Admin access required"}), 403

    try:
        validator = ConfigValidator()
        validator.validate_all()

        health_data = {
            "status": "healthy" if not validator.errors else "degraded",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "validation": {
                "errors": validator.errors,
                "warnings": validator.warnings,
                "info": validator.info,
            },
        }

        return jsonify(health_data)

    except Exception as e:
        return (
            jsonify(
                {
                    "status": "unhealthy",
                    "error": str(e),
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                }
            ),
            500,
        )


@main_bp.route("/admin/config/validate")
def admin_validate_config():
    """Admin endpoint to validate system configuration."""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    if not is_system_admin_user(user):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))

    validator = ConfigValidator()
    validator.validate_all()

    return render_template(
        "admin_config_validate.html",
        errors=validator.errors,
        warnings=validator.warnings,
        info=validator.info,
    )


@main_bp.route("/admin/browser-info", methods=["GET"])
def admin_browser_info():
    """Display browser and system detection information"""
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    if not is_system_admin_user(user):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))

    return render_template("browser_info.html")


@main_bp.route("/admin/tools", methods=["GET"])
def admin_tools():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    if not is_system_admin_user(user):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))

    # Attempt to read logs from configured log dir, fallback to journalctl if available
    memwatch_log = ""
    autodeploy_log = ""
    log_dir = config.LOG_DIR  # Already OS-aware from config.py
    mem_file = os.path.join(log_dir, "memwatch.log")
    auto_file = os.path.join(log_dir, "autodeploy.log")

    # Check if journalctl is available
    has_journalctl = shutil.which("journalctl") is not None

    try:
        if os.path.exists(mem_file):
            with open(mem_file, "r") as f:
                memwatch_log = "".join(f.readlines()[-400:])
        elif has_journalctl:
            memwatch_log = subprocess.run(
                ["journalctl", "-u", "memwatch.service", "-n", "200", "--no-pager"],
                capture_output=True,
                text=True,
            ).stdout
        else:
            memwatch_log = (
                "Memwatch log not available. Log file not found and journalctl not available "
                "(development environment)."
            )
    except Exception as e:
        memwatch_log = f"Could not read memwatch log: {e}"

    try:
        if os.path.exists(auto_file):
            with open(auto_file, "r") as f:
                autodeploy_log = "".join(f.readlines()[-400:])
        elif has_journalctl:
            autodeploy_log = subprocess.run(
                ["journalctl", "-u", "autodeploy.service", "-n", "200", "--no-pager"],
                capture_output=True,
                text=True,
            ).stdout
        else:
            autodeploy_log = (
                "Autodeploy log not available. Log file not found and journalctl not available "
                "(development environment)."
            )
    except Exception as e:
        autodeploy_log = f"Could not read autodeploy log: {e}"

    return render_template(
        "admin_tools.html", memwatch_log=memwatch_log, autodeploy_log=autodeploy_log
    )


def _migrate_theme_into_db():
    """Migration helper: import existing static CSS and instance flag into DB if missing.

    This runs at first request to ensure it executes under WSGI servers too.
    """
    try:
        s_css = SiteSetting.query.filter_by(key="custom_theme_css").first()
        theme_path = os.path.join(app.root_path, "static", "css", "custom_theme.css")
        if not s_css and os.path.exists(theme_path):
            with open(theme_path, "r", encoding="utf-8") as f:
                css = f.read()
            s_css = SiteSetting(key="custom_theme_css", value=css)
            db.session.add(s_css)

        s_flag = SiteSetting.query.filter_by(key="theme_enabled").first()
        flag_path = os.path.join(app.root_path, "instance", "theme_enabled")
        if not s_flag and os.path.exists(flag_path):
            try:
                with open(flag_path, "r", encoding="utf-8") as f:
                    v = f.read().strip()
                s_flag = SiteSetting(key="theme_enabled", value=("1" if v == "1" else "0"))
                db.session.add(s_flag)
            except Exception:
                pass

        if s_css or s_flag:
            db.session.commit()
    except Exception:
        try:
            db.session.rollback()
        except Exception:
            pass


@app.before_request
def ensure_theme_migration_once():
    # Run migration once before handling the first request. Uses a module-level
    # flag to avoid repeated work and is safe under WSGI servers.
    if getattr(app, "_theme_migrated", False):
        return
    try:
        db.create_all()
    except Exception:
        pass
    _migrate_theme_into_db()
    app._theme_migrated = True


@main_bp.route("/theme.css")
def theme_css():
    """Serve the custom theme CSS from the DB dynamically.

    Returns an empty response (200, text/css) when no CSS stored.
    """
    try:
        s_css = SiteSetting.query.filter_by(key="custom_theme_css").first()
        css = s_css.value if (s_css and s_css.value) else ""
    except Exception:
        css = ""
    return Response(css, mimetype="text/css")


@main_bp.route("/theme_asset/<path:filename>")
def theme_asset(filename):
    # Deprecated filename-based route: try to find by filename (filesystem or DB)
    assets_dir = os.path.join(app.root_path, "instance", "theme_assets")
    safe = secure_filename(filename)
    file_path = os.path.join(assets_dir, safe)
    if os.path.exists(file_path):
        return send_file(file_path)
    sa = SiteAsset.query.filter_by(filename=safe).first()
    if sa:
        return Response(sa.data, mimetype=sa.mimetype or "application/octet-stream")
    abort(404)


@main_bp.route("/theme_asset/id/<int:asset_id>")
def theme_asset_by_id(asset_id):
    # Serve asset by DB id (preferred)
    sa = db.session.get(SiteAsset, asset_id)
    if sa:
        return Response(sa.data, mimetype=sa.mimetype or "application/octet-stream")
    # fallback to filesystem with name equal to id (unlikely)
    abort(404)


@main_bp.route("/theme_asset/thumb/<int:asset_id>")
def theme_asset_thumb(asset_id):
    # produce a small thumbnail (PNG) for the asset
    sa = db.session.get(SiteAsset, asset_id)
    if not sa:
        abort(404)
    try:
        img = Image.open(io.BytesIO(sa.data))
        img = ImageOps.exif_transpose(img)
        img.thumbnail((128, 128))
        out = io.BytesIO()
        # serve thumbnail as PNG for broad support
        img.save(out, format="PNG")
        out.seek(0)
        return Response(out.read(), mimetype="image/png")
    except Exception:
        abort(404)


@main_bp.route("/admin/theme", methods=["GET", "POST"])
def admin_theme():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    if not is_system_admin_user(user):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))

    theme_path = os.path.join(app.root_path, "static", "css", "custom_theme.css")
    if request.method == "POST":
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("admin_theme"))
        # handle file upload when upload=1 query param present
        if request.args.get("upload") == "1" and "logo" in request.files:
            f: FileStorage = request.files.get("logo")
            if f and f.filename:
                filename = secure_filename(f.filename)
                # read file bytes for validation and storage
                try:
                    data = f.read()
                except Exception as e:
                    flash(f"Error reading uploaded file: {e}", "error")
                    return redirect(url_for("admin_theme"))

                # validation: size
                max_bytes = app.config.get(
                    "THEME_UPLOAD_MAX_BYTES",
                    getattr(config, "THEME_UPLOAD_MAX_BYTES", 1_048_576),
                )
                if len(data) > max_bytes:
                    flash(f"File too large (max {max_bytes} bytes)", "error")
                    return redirect(url_for("admin_theme"))

                # validation: mime/type detection using Pillow (or SVG quick-check)
                allowed_mimes = app.config.get(
                    "THEME_ALLOWED_MIMES",
                    getattr(
                        config,
                        "THEME_ALLOWED_MIMES",
                        "image/png,image/jpeg,image/gif,image/webp,image/svg+xml",
                    ),
                ).split(",")
                is_svg = False
                try:
                    head = data[:512].lstrip()
                    if head.startswith(b"<") and (
                        b"<svg" in head.lower() or b"<?xml" in head.lower()
                    ):
                        is_svg = True
                except Exception:
                    is_svg = False

                effective_mime = None
                processed_bytes = data
                # If SVG, accept if allowed
                if is_svg:
                    effective_mime = "image/svg+xml"
                else:
                    # Try opening with Pillow
                    try:
                        img = Image.open(io.BytesIO(data))
                        fmt = (img.format or "").upper()
                        if not fmt:
                            raise Exception("Unknown image format")
                        img = ImageOps.exif_transpose(img)

                        # optional resize / normalization
                        max_w = app.config.get(
                            "THEME_MAX_WIDTH", getattr(config, "THEME_MAX_WIDTH", 2048)
                        )
                        max_h = app.config.get(
                            "THEME_MAX_HEIGHT",
                            getattr(config, "THEME_MAX_HEIGHT", 2048),
                        )
                        if img.width > max_w or img.height > max_h:
                            img.thumbnail((max_w, max_h))

                        # normalize mode for JPEG
                        out_io = io.BytesIO()
                        # Normalize everything to PNG for thumbnails/logos to avoid
                        # format-specific save issues and ensure broad browser support.
                        if img.mode in ("RGBA", "LA"):
                            out = img
                        else:
                            out = img.convert("RGBA")
                        out.save(out_io, format="PNG")
                        processed_bytes = out_io.getvalue()
                        effective_mime = "image/png"
                    except Exception as e:
                        import traceback

                        tb = traceback.format_exc()
                        try:
                            app.logger.error("Theme image processing error: %s\n%s", e, tb)
                        except Exception:
                            logger.error(f"Theme image processing error: {e}")
                            logger.debug(tb)
                        flash(f"Could not process uploaded image: {e}", "error")
                        return redirect(url_for("admin_theme"))

                if effective_mime not in allowed_mimes:
                    flash(f"Invalid file type: {effective_mime}", "error")
                    return redirect(url_for("admin_theme"))

                # store either in DB or filesystem
                store_in_db = app.config.get(
                    "THEME_STORE_IN_DB", getattr(config, "THEME_STORE_IN_DB", False)
                )
                try:
                    if store_in_db:
                        # upsert by filename
                        sa = SiteAsset.query.filter_by(filename=filename).first()
                        if not sa:
                            sa = SiteAsset(
                                filename=filename,
                                data=processed_bytes,
                                mimetype=effective_mime,
                            )
                        else:
                            sa.data = processed_bytes
                            sa.mimetype = effective_mime
                        db.session.add(sa)
                        db.session.commit()
                    else:
                        assets_dir = os.path.join(app.root_path, "instance", "theme_assets")
                        os.makedirs(assets_dir, exist_ok=True)
                        save_path = os.path.join(assets_dir, filename)
                        with open(save_path, "wb") as wf:
                            wf.write(processed_bytes)
                    flash(f"Logo uploaded: {filename}", "success")
                except Exception as e:
                    db.session.rollback()
                    flash(f"Error saving logo: {e}", "error")
            return redirect(url_for("admin_theme"))
        # handle delete logo
        # single delete via asset id
        if request.form.get("delete_asset_id"):
            try:
                aid = int(request.form.get("delete_asset_id"))
            except Exception:
                aid = None
            if aid:
                try:
                    sa = db.session.get(SiteAsset, aid)
                    if sa:
                        # remove filesystem copy if exists
                        assets_dir = os.path.join(app.root_path, "instance", "theme_assets")
                        fs_path = os.path.join(assets_dir, sa.filename)
                        if os.path.exists(fs_path):
                            os.remove(fs_path)

                        # also remove any previews
                        thumb_path = os.path.join(assets_dir, "thumb_" + sa.filename)
                        if os.path.exists(thumb_path):
                            os.remove(thumb_path)

                        db.session.delete(sa)
                        db.session.commit()
                        flash(f"Deleted logo id={aid}", "success")
                    else:
                        flash("Asset not found", "error")
                except Exception as e:
                    db.session.rollback()
                    flash(f"Error deleting asset: {e}", "error")
            return redirect(url_for("admin_theme"))

        # bulk delete
        if request.args.get("bulk_delete") == "1" and request.form.getlist("asset_ids"):
            ids = request.form.getlist("asset_ids")
            deleted = 0
            for sid in ids:
                try:
                    aid = int(sid)
                except Exception:
                    continue
                sa = db.session.get(SiteAsset, aid)
                try:
                    if sa:
                        assets_dir = os.path.join(app.root_path, "instance", "theme_assets")
                        fs_path = os.path.join(assets_dir, sa.filename)
                        if os.path.exists(fs_path):
                            os.remove(fs_path)

                        # also remove any previews
                        thumb_path = os.path.join(assets_dir, "thumb_" + sa.filename)
                        if os.path.exists(thumb_path):
                            os.remove(thumb_path)

                        db.session.delete(sa)
                        deleted += 1
                except Exception:
                    db.session.rollback()
            try:
                db.session.commit()
            except Exception:
                db.session.rollback()
            flash(f"Deleted {deleted} assets", "success")
            return redirect(url_for("admin_theme"))
        css = request.form.get("css", "")
        # handle theme enabled toggle
        enabled = request.form.get("enabled") == "1"
        toggle_enabled = request.form.get("toggle_enabled") == "1"
        forced_theme = request.form.get("forced_theme", "").strip()
        if forced_theme not in ("dark", "light"):
            forced_theme = ""
        try:
            # persist to DB (upsert)
            s_css = SiteSetting.query.filter_by(key="custom_theme_css").first()
            if not s_css:
                s_css = SiteSetting(key="custom_theme_css", value=css)
            else:
                s_css.value = css
            s_flag = SiteSetting.query.filter_by(key="theme_enabled").first()
            if not s_flag:
                s_flag = SiteSetting(key="theme_enabled", value=("1" if enabled else "0"))
            else:
                s_flag.value = "1" if enabled else "0"
            s_toggle = SiteSetting.query.filter_by(key="theme_toggle_enabled").first()
            if not s_toggle:
                s_toggle = SiteSetting(
                    key="theme_toggle_enabled", value=("1" if toggle_enabled else "0")
                )
            else:
                s_toggle.value = "1" if toggle_enabled else "0"
            s_forced = SiteSetting.query.filter_by(key="theme_forced").first()
            if not s_forced:
                s_forced = SiteSetting(key="theme_forced", value=forced_theme)
            else:
                s_forced.value = forced_theme
            db.session.add(s_css)
            db.session.add(s_flag)
            db.session.add(s_toggle)
            db.session.add(s_forced)
            db.session.commit()

            flash("Theme saved", "success")
        except Exception as e:
            db.session.rollback()
            flash(f"Error saving theme: {e}", "error")
        return redirect(url_for("admin_theme"))

    # handle listing/uploading logos
    assets = []
    try:
        # list DB-stored assets
        assets = SiteAsset.query.order_by(SiteAsset.created_at.desc()).all()
    except Exception:
        assets = []

    css = ""
    try:
        # prefer DB-stored CSS
        s_css = SiteSetting.query.filter_by(key="custom_theme_css").first()
        if s_css and s_css.value is not None:
            css = s_css.value
        else:
            # fallback: try to read existing static file (migration path)
            if os.path.exists(theme_path):
                with open(theme_path, "r", encoding="utf-8") as f:
                    css = f.read()
    except Exception as e:
        flash(f"Error reading theme file or DB: {e}", "error")

    return render_template("admin_theme.html", css=css, assets=assets)


@main_bp.route("/admin/users/role", methods=["POST"])
def admin_set_role():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    actor = db.session.get(User, uid)
    from rbac import has_permission
    if not has_permission(actor, "admin.user_management"):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    try:
        verify_csrf()
    except Exception:
        flash("Invalid CSRF token", "error")
        return redirect(url_for("admin_users"))
    user_id = request.form.get("user_id")
    new_role = request.form.get("role")
    u = db.session.get(User, int(user_id)) if user_id else None
    if not u:
        flash("User not found", "error")
        return redirect(url_for("admin_users"))
    old = u.role
    u.role = new_role
    db.session.add(AuditLog(actor_id=actor.id, action=f"changed_role:{u.email}:{old}->{new_role}"))
    db.session.commit()
    flash("Role updated", "success")
    return redirect(url_for("admin_users"))


@main_bp.route("/admin/servers", methods=["GET"])
def admin_servers():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    from rbac import has_permission
    if not has_permission(user, "admin.server_management"):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    servers = Server.query.order_by(Server.name).all()
    return render_template("admin_servers.html", servers=servers)


@main_bp.route("/admin/servers/create", methods=["GET", "POST"])
def admin_create_server():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    actor = db.session.get(User, uid)
    from rbac import has_permission
    if not has_permission(actor, "admin.server_management"):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    if request.method == "POST":
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("admin_create_server"))
        name = request.form.get("name", "").strip()
        desc = request.form.get("description", "").strip()
        game_type = request.form.get("game_type", "etlegacy").strip()
        host = request.form.get("host", "").strip()
        port_str = request.form.get("port", "").strip()
        rcon_password = request.form.get("rcon_password", "").strip()

        if not name:
            flash("Name is required", "error")
            return redirect(url_for("admin_create_server"))
        if Server.query.filter_by(name=name).first():
            flash("Server name already exists", "error")
            return redirect(url_for("admin_create_server"))

        # Validate port if provided
        port = None
        if port_str:
            try:
                port = int(port_str)
                if not (1 <= port <= 65535):
                    flash("Port must be between 1 and 65535", "error")
                    return redirect(url_for("admin_create_server"))
            except ValueError:
                flash("Invalid port number", "error")
                return redirect(url_for("admin_create_server"))

        # Load default config template for selected game type
        from config_manager import ConfigTemplate

        template = ConfigTemplate.query.filter_by(game_type=game_type, is_default=True).first()

        if template:
            # Load config from template
            template_data = json.loads(template.template_data)
            default_vars = template_data.get("variables", {})
            raw_config = template_data.get("config_content", "# default config\n")
        else:
            # Fallback to basic config if no template
            default_vars = {"max_players": 16, "map": "default", "motd": "Welcome"}
            raw_config = "# default config\n"

        # Create server with loaded config
        s = Server(
            name=name,
            description=desc,
            game_type=game_type,
            host=host if host else None,
            port=port,
            rcon_password=rcon_password if rcon_password else None,
            variables_json=json.dumps(default_vars, indent=2),
            raw_config=raw_config,
        )
        db.session.add(s)
        db.session.commit()

        # Assign creator as server_admin
        su = ServerUser(server_id=s.id, user_id=actor.id, role="server_admin")
        db.session.add(su)
        db.session.add(AuditLog(actor_id=actor.id, action=f"create_server:{name}:{game_type}"))
        db.session.commit()

        flash(f"Server '{name}' created successfully with {game_type} configuration", "success")
        return redirect(url_for("admin_servers"))

    # GET request - get available game types from templates
    from config_manager import ConfigTemplate

    game_types = db.session.query(ConfigTemplate.game_type).distinct().all()
    game_types = [gt[0] for gt in game_types] if game_types else ["etlegacy"]

    return render_template("server_create.html", game_types=game_types)


@main_bp.route("/admin/servers/<int:server_id>/delete", methods=["POST"])
def admin_delete_server(server_id):
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    actor = db.session.get(User, uid)
    from rbac import has_permission
    if not has_permission(actor, "admin.server_management"):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    try:
        verify_csrf()
    except Exception:
        flash("Invalid CSRF token", "error")
        return redirect(url_for("admin_servers"))
    s = db.session.get(Server, server_id)
    if not s:
        flash("Server not found", "error")
        return redirect(url_for("admin_servers"))
    name = s.name
    db.session.delete(s)
    db.session.add(AuditLog(actor_id=actor.id, action=f"delete_server:{name}"))
    db.session.commit()
    flash("Server deleted", "success")
    return redirect(url_for("admin_servers"))


@main_bp.route("/admin/audit", methods=["GET"])
def admin_audit():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    from rbac import has_permission
    if not has_permission(user, "admin.audit_view"):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    # pagination & filtering
    page = int(request.args.get("page", 1))
    per_page = int(request.args.get("per_page", 50))
    actor_filter = request.args.get("actor")
    action_filter = request.args.get("action")
    q = AuditLog.query
    if actor_filter:
        # try to resolve actor id by email
        a_user = User.query.filter_by(email=actor_filter.lower()).first()
        if a_user:
            q = q.filter(AuditLog.actor_id == a_user.id)
        else:
            q = q.filter(AuditLog.action.contains(actor_filter))
    if action_filter:
        q = q.filter(AuditLog.action.contains(action_filter))
    total = q.count()
    entries = (
        q.order_by(AuditLog.created_at.desc()).offset((page - 1) * per_page).limit(per_page).all()
    )
    resolved = []
    for e in entries:
        actor = db.session.get(User, e.actor_id) if e.actor_id else None
        resolved.append(
            {
                "id": e.id,
                "actor": actor.email if actor else None,
                "action": e.action,
                "ts": e.created_at,
            }
        )
    return render_template(
        "admin_audit.html",
        entries=resolved,
        page=page,
        per_page=per_page,
        total=total,
        actor_filter=actor_filter or "",
        action_filter=action_filter or "",
    )


@main_bp.route("/admin/audit/export", methods=["GET"])
def admin_audit_export():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    if not is_system_admin_user(user):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    actor_filter = request.args.get("actor")
    action_filter = request.args.get("action")
    # Build raw SQL query with filters
    sql = (
        "SELECT audit_log.id, audit_log.created_at, user.email, audit_log.action "
        "FROM audit_log LEFT JOIN user ON audit_log.actor_id = user.id WHERE 1=1"
    )
    params = []
    if actor_filter:
        # resolve actor email
        a_user = db.session.query(User).filter_by(email=actor_filter.lower()).first()
        if a_user:
            sql += " AND audit_log.actor_id = %s"
            params.append(a_user.id)
        else:
            sql += " AND audit_log.action LIKE %s"
            params.append(f"%{actor_filter}%")
    if action_filter:
        sql += " AND audit_log.action LIKE %s"
        params.append(f"%{action_filter}%")
    sql += " ORDER BY audit_log.created_at DESC"

    # stream CSV using raw SQL cursor
    def generate():
        import csv
        from io import StringIO

        buf = StringIO()
        writer = csv.writer(buf)
        writer.writerow(["id", "timestamp", "actor", "action"])

        buf.seek(0)
        buf.truncate(0)
        # use raw connection cursor to avoid ORM overhead
        with db.engine.connect() as conn:
            result = conn.execute(text(sql), params)
            for row in result:
                audit_id, ts, actor_email, action = row
                ts_str = ""
                if ts:
                    # handle both datetime objects and string timestamps (SQLite returns strings)
                    ts_str = ts.isoformat() if hasattr(ts, "isoformat") else str(ts)
                writer.writerow([audit_id, ts_str, actor_email or "", action])
                yield buf.getvalue()
                buf.seek(0)
                buf.truncate(0)

    from flask import Response

    headers = {"Content-Disposition": 'attachment; filename="audit.csv"'}
    return Response(generate(), mimetype="text/csv", headers=headers)


@main_bp.route("/admin/users", methods=["GET"])
def admin_users():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    from rbac import has_permission
    if not has_permission(user, "admin.user_management"):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    users = User.query.order_by(User.email).all()
    # csrf_token is available via context processor, but explicitly pass it for the template
    return render_template(
        "admin_users.html", users=users, csrf_token=lambda: session.get("csrf_token", "")
    )


@main_bp.route("/server/<int:server_id>", methods=["GET", "POST"])
def server_edit(server_id):
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    server = db.session.get(Server, server_id)
    if not server:
        flash("Server not found", "error")
        return redirect(url_for("dashboard"))
    if not user_can_edit_server(user, server):
        flash("Insufficient privileges for this server", "error")
        return redirect(url_for("dashboard"))
    if request.method == "POST":
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("server_edit", server_id=server_id))
        # accept either structured JSON variables or raw config
        vars_text = request.form.get("variables_json", "").strip()
        raw_cfg = request.form.get("raw_config", "")
        host = request.form.get("host", "").strip()
        port_str = request.form.get("port", "").strip()
        rcon_password = request.form.get("rcon_password", "").strip()

        # Update connection details
        server.host = host if host else None
        server.rcon_password = rcon_password if rcon_password else None

        if port_str:
            try:
                port = int(port_str)
                if 1 <= port <= 65535:
                    server.port = port
                else:
                    flash("Port must be between 1 and 65535", "error")
                    return redirect(url_for("server_edit", server_id=server_id))
            except ValueError:
                flash("Invalid port number", "error")
                return redirect(url_for("server_edit", server_id=server_id))
        else:
            server.port = None

        if vars_text:
            try:
                parsed = json.loads(vars_text)
                # store pretty-printed JSON
                server.variables_json = json.dumps(parsed, indent=2)
            except Exception as e:
                flash(f"Invalid JSON: {e}", "error")
                return redirect(url_for("server_edit", server_id=server_id))
        server.raw_config = raw_cfg
        db.session.add(AuditLog(actor_id=user.id, action=f"edit_server:{server.name}"))
        db.session.commit()
        flash("Server updated", "success")
        return redirect(url_for("server_edit", server_id=server_id))
    # GET
    return render_template("server_edit.html", server=server, user=user)


@main_bp.route("/admin/server/<int:server_id>/manage_users", methods=["GET", "POST"])
def admin_server_manage_users(server_id):
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    actor = db.session.get(User, uid)
    from rbac import has_permission
    if not has_permission(actor, "admin.server_management"):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    server = db.session.get(Server, server_id)
    if not server:
        flash("Server not found", "error")
        return redirect(url_for("admin_servers"))
    if request.method == "POST":
        try:
            verify_csrf()
        except Exception:
            flash("Invalid CSRF token", "error")
            return redirect(url_for("admin_server_manage_users", server_id=server_id))
        # expected form inputs: user_<id> = role or empty
        users = User.query.order_by(User.email).all()
        # remove existing mappings
        ServerUser.query.filter_by(server_id=server.id).delete()
        for u in users:
            key = f"user_{u.id}"
            role = request.form.get(key)
            if role in ("server_admin", "server_mod"):
                su = ServerUser(server_id=server.id, user_id=u.id, role=role)
                db.session.add(su)
                db.session.add(
                    AuditLog(
                        actor_id=actor.id,
                        action=f"assign_server_role:{server.name}:{u.email}->{role}",
                    )
                )
        db.session.commit()
        flash("Server user assignments updated", "success")
        return redirect(url_for("admin_server_manage_users", server_id=server_id))

    users = User.query.order_by(User.email).all()
    assignments = {su.user_id: su.role for su in server.users}
    return render_template(
        "admin_server_manage.html", server=server, users=users, assignments=assignments
    )


@main_bp.route("/admin/jobs", methods=["GET"])
def admin_jobs():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    from rbac import has_permission
    if not has_permission(user, "admin.job_management"):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))

    # Pagination and filtering
    page = int(request.args.get("page", 1))
    per_page = int(request.args.get("per_page", 20))
    status_filter = request.args.get("status")  # queued, started, finished, failed
    func_filter = request.args.get("func")
    q = AuditLog.query
    if status_filter:
        q = q.filter(AuditLog.action == status_filter)
    if func_filter:
        q = q.filter(AuditLog.action.contains(func_filter))
    total = q.count()
    entries = q.order_by(AuditLog.created_at.desc()).offset((page - 1) * per_page).limit(per_page).all()
    return render_template("admin_jobs.html", entries=entries, page=page, per_page=per_page, total=total)


@main_bp.route("/admin/trigger_autodeploy", methods=["POST"])
def trigger_autodeploy():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    if not is_admin_user(user):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    try:
        verify_csrf()
    except Exception:
        flash("Invalid CSRF token", "error")
        return redirect(url_for("admin_tools"))

    # Enqueue autodeploy task (background)
    try:
        redis_url = os.environ.get("PANEL_REDIS_URL", config.REDIS_URL)
        rconn = redis.from_url(redis_url)
        q = Queue("default", connection=rconn)
        job = q.enqueue(tasks.run_autodeploy, timeout=3600)
        flash(f"Autodeploy enqueued (job id={job.id})", "info")
        return redirect(url_for("admin_tools"))
    except Exception as e:
        flash(f"Failed to enqueue autodeploy: {e}", "error")
        return redirect(url_for("admin_tools"))


@main_bp.route("/admin/run_memdump", methods=["POST"])
def run_memdump():
    uid = session.get("user_id")
    if not uid:
        return redirect(url_for("login"))
    user = db.session.get(User, uid)
    if not is_admin_user(user):
        flash("Admin access required", "error")
        return redirect(url_for("dashboard"))
    try:
        verify_csrf()
    except Exception:
        flash("Invalid CSRF token", "error")
        return redirect(url_for("admin_tools"))

    pid_file = request.form.get("pid_file") or config.ET_PID_FILE  # Already OS-aware from config.py
    # Enqueue memwatch task (background)
    try:
        redis_url = os.environ.get("PANEL_REDIS_URL", config.REDIS_URL)
        rconn = redis.from_url(redis_url)
        q = Queue("default", connection=rconn)
        job = q.enqueue(tasks.run_memwatch, pid_file, timeout=600)
        flash(f"Memwatch enqueued (job id={job.id})", "info")
        return redirect(url_for("admin_tools"))
    except Exception as e:
        flash(f"Failed to enqueue memwatch: {e}", "error")
        return redirect(url_for("admin_tools"))


@main_bp.route("/admin/job/<job_id>")
def admin_job_status(job_id):
    try:
        redis_url = os.environ.get("PANEL_REDIS_URL", config.REDIS_URL)
        rconn = redis.from_url(redis_url)
        from rq.job import Job

        job = Job.fetch(job_id, connection=rconn)
        status = job.get_status()
        result = job.result
        return {"id": job_id, "status": status, "result": result}
    except Exception as e:
        return {"error": str(e)}, 500


@main_bp.route("/api/theme_pref", methods=["POST"])
def api_theme_pref():
    uid = session.get("user_id")
    if not uid:
        return {"ok": False, "error": "auth required"}, 401
    try:
        verify_csrf()
    except Exception:
        return {"ok": False, "error": "bad csrf"}, 400
    theme = request.form.get("theme", "").strip()
    if theme not in ("dark", "light"):
        return {"ok": False, "error": "invalid theme"}, 400
    try:
        key = f"user_theme:{uid}"
        s = db.session.query(SiteSetting).filter_by(key=key).first()
        if not s:
            s = SiteSetting(key=key, value=theme)
            db.session.add(s)
        else:
            s.value = theme
        db.session.commit()
        return {"ok": True}
    except Exception as e:
        db.session.rollback()
        return {"ok": False, "error": str(e)}, 500


if __name__ == "__main__":
    # Use basic logging for startup messages before app context
    import logging as startup_logging

    startup_logging.basicConfig(level=startup_logging.INFO, format="%(levelname)s: %(message)s")
    startup_logger = startup_logging.getLogger(__name__)

    # create DB tables if not exist
    with app.app_context():
        db.create_all()
        # Simple migration: if theme data exists as files but not in DB, import them
        try:
            # import css file if present and DB empty
            s_css = SiteSetting.query.filter_by(key="custom_theme_css").first()
            theme_path = os.path.join(app.root_path, "static", "css", "custom_theme.css")
            if not s_css and os.path.exists(theme_path):
                with open(theme_path, "r", encoding="utf-8") as f:
                    css = f.read()
                s_css = SiteSetting(key="custom_theme_css", value=css)
                db.session.add(s_css)

            # import enabled flag from instance file if present and DB empty
            s_flag = SiteSetting.query.filter_by(key="theme_enabled").first()
            flag_path = os.path.join(app.root_path, "instance", "theme_enabled")
            if not s_flag and os.path.exists(flag_path):
                try:
                    with open(flag_path, "r", encoding="utf-8") as f:
                        v = f.read().strip()
                    s_flag = SiteSetting(key="theme_enabled", value=("1" if v == "1" else "0"))
                    db.session.add(s_flag)
                except Exception:
                    pass

            if s_css or s_flag:
                db.session.commit()
        except Exception:
            db.session.rollback()

    # Import extended routes
    # Temporarily commented out to avoid circular imports during monitoring system integration
    # import routes_extended
    # import routes_rbac
    from monitoring_system import monitoring_bp, start_monitoring

    # Enterprise systems temporarily disabled to avoid SQLAlchemy context issues
    from routes_config import config_bp

    # from api_monitoring import api_bp
    # from log_analytics import log_analytics_bp, start_log_analytics
    # from multi_server_management import multi_server_bp, start_multi_server_system
    # Register config blueprint for Ptero-Eggs management
    app.register_blueprint(config_bp)
    # Register other blueprints - Temporarily disabled
    app.register_blueprint(monitoring_bp)
    # app.register_blueprint(api_bp)
    # app.register_blueprint(log_analytics_bp)
    # app.register_blueprint(multi_server_bp)
    logger.info(
        "Configuration management enabled, other enterprise systems disabled for clean operation"
    )

    # Initialize configuration templates after database is ready
    from config_manager import create_default_templates

    try:
        create_default_templates()
    except Exception as e:
        # Silently ignore template creation errors during startup
        logger.debug(f"Template creation skipped: {e}")

    logger.info("Panel application ready for use")

    # Read host and port from environment or config
    host = os.environ.get("FLASK_HOST", "0.0.0.0")
    port = int(os.environ.get("FLASK_PORT", 8080))
    debug = os.environ.get("FLASK_DEBUG", "True").lower() in ("true", "1", "yes")

    app.run(host=host, port=port, debug=debug)


# ===== Database Admin Integration Routes =====


def requires_admin_or_system_admin(f):
    """Decorator to require admin or system admin access"""

    def decorated_function(*args, **kwargs):
        if "user_id" not in session:
            flash("Please log in to access this area.", "error")
            return redirect(url_for("login"))

        user = db.session.get(User, session["user_id"])
        if not user or not (user.is_system_admin() or user.is_server_admin()):
            flash("Insufficient permissions.", "error")
            return redirect(url_for("dashboard"))

        return f(*args, **kwargs)

    decorated_function.__name__ = f.__name__
    return decorated_function


@main_bp.route("/admin/database")
@requires_admin_or_system_admin
def admin_db_home():
    """Database management home page"""
    db_info = db_admin.get_database_info()
    return render_template_string(
        DATABASE_ADMIN_BASE_TEMPLATE + DATABASE_ADMIN_HOME_TEMPLATE,
        db_info=db_info,
        breadcrumb="Database Management",
    )


@main_bp.route("/admin/database/table/<table_name>")
@requires_admin_or_system_admin
def admin_db_table(table_name):
    """View table data with pagination"""
    limit = int(request.args.get("limit", 50))
    offset = int(request.args.get("offset", 0))

    result = db_admin.get_table_data(table_name, limit, offset)

    # Get total count for pagination (simplified)
    total_result = db_admin.execute_query(f"SELECT COUNT(*) as count FROM `{table_name}`")
    total = total_result["data"][0]["count"] if total_result["success"] else 0

    return render_template_string(
        DATABASE_ADMIN_BASE_TEMPLATE + DATABASE_ADMIN_TABLE_TEMPLATE,
        table_name=table_name,
        result=result,
        limit=limit,
        offset=offset,
        total=total,
        breadcrumb=f"Database Management &gt; Table: {table_name}",
    )


@main_bp.route("/admin/database/table/<table_name>/structure")
@requires_admin_or_system_admin
def admin_db_table_structure(table_name):
    """View table structure"""
    result = db_admin.get_table_structure(table_name)
    return render_template_string(
        DATABASE_ADMIN_BASE_TEMPLATE
        + """
        {% block content %}
        <div class="main-content">
            <h2>Table Structure: {{ table_name }}</h2>
            <a href="{{ url_for('admin_db_table', table_name=table_name) }}" class="btn">View Data</a>

            {% if result.success %}
            <table>
                <thead>
                    <tr>
                        {% for column in result.data[0].keys() %}
                        <th>{{ column }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for row in result.data %}
                    <tr>
                        {% for value in row.values() %}
                        <td>{{ value if value is not none else '<em>NULL</em>' }}</td>
                        {% endfor %}
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
            {% else %}
                <div class="alert alert-danger">Error: {{ result.error }}</div>
            {% endif %}
        </div>
        {% endblock %}
        """,
        table_name=table_name,
        result=result,
        breadcrumb=f"Database Management &gt; Table: {table_name} &gt; Structure",
    )


@main_bp.route("/admin/database/query", methods=["GET", "POST"])
@requires_admin_or_system_admin
def admin_db_query():
    """Execute custom SQL queries"""
    query = request.args.get("query", "")
    result = None

    if request.method == "POST":
        query = request.form.get("query", "").strip()
        if query:
            # Basic security: prevent dangerous operations
            dangerous_keywords = [
                "DROP",
                "DELETE",
                "TRUNCATE",
                "ALTER",
                "CREATE",
                "INSERT",
                "UPDATE",
            ]
            query_upper = query.upper()

            # Allow SELECT and SHOW queries, warn about others
            if any(keyword in query_upper for keyword in dangerous_keywords):
                if not request.form.get("confirm_dangerous"):
                    flash(
                        "This query contains potentially dangerous operations. "
                        "Please confirm if you want to proceed.",
                        "warning",
                    )
                    return render_template_string(
                        DATABASE_ADMIN_BASE_TEMPLATE
                        + DATABASE_ADMIN_QUERY_TEMPLATE
                        + """
                        <form method="post" style="background: #fff3cd; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                            <input type="hidden" name="query" value="{{ query }}">
                            <p><strong>⚠️ Warning:</strong> This query may modify your database. Are you sure?</p>
                            <button type="submit" name="confirm_dangerous" value="1" class="btn btn-danger">Yes, Execute</button>
                            <a href="{{ url_for('admin_db_query') }}" class="btn">Cancel</a>
                        </form>
                        """,
                        query=query,
                        result=None,
                        breadcrumb="Database Management &gt; SQL Query",
                    )

            result = db_admin.execute_query(query)

    return render_template_string(
        DATABASE_ADMIN_BASE_TEMPLATE + DATABASE_ADMIN_QUERY_TEMPLATE,
        query=query,
        result=result,
        breadcrumb="Database Management &gt; SQL Query",
    )


@main_bp.route("/admin/database/export")
@requires_admin_or_system_admin
def admin_db_export():
    """Export database"""
    return render_template_string(
        DATABASE_ADMIN_BASE_TEMPLATE
        + """
        {% block content %}
        <div class="main-content">
            <h2>Export Database</h2>
            <p>Database export functionality will be implemented here.</p>

            <h3>Quick Exports</h3>
            <a href="{{ url_for('admin_db_export_table', table_name='user') }}" class="btn">Export Users</a>
            <a href="{{ url_for('admin_db_export_table', table_name='game_server') }}" class="btn">Export Servers</a>

            <h3>Export Options</h3>
            <form method="post">
                <p><label><input type="checkbox" name="include_data" checked> Include Data</label></p>
                <p><label><input type="checkbox" name="include_structure" checked> Include Structure</label></p>
                <button type="submit" class="btn btn-success">Export Database</button>
            </form>
        </div>
        {% endblock %}
        """,
        breadcrumb="Database Management &gt; Export",
    )


@main_bp.route("/admin/database/export/<table_name>")
@requires_admin_or_system_admin
def admin_db_export_table(table_name):
    """Export specific table as CSV"""
    result = db_admin.execute_query(f"SELECT * FROM `{table_name}`")

    if not result["success"]:
        flash(f'Error exporting table: {result["error"]}', "error")
        return redirect(url_for("admin_db_export"))

    # Generate CSV
    import csv
    import io

    output = io.StringIO()
    if result["data"]:
        writer = csv.DictWriter(output, fieldnames=result["data"][0].keys())
        writer.writeheader()
        writer.writerows(result["data"])

    response = Response(
        output.getvalue(),
        mimetype="text/csv",
        headers={"Content-Disposition": f"attachment;filename={table_name}_export.csv"},
    )
    return response


@main_bp.route("/admin/database/import")
@requires_admin_or_system_admin
def admin_db_import():
    """Import database"""
    return render_template_string(
        DATABASE_ADMIN_BASE_TEMPLATE
        + """
        {% block content %}
        <div class="main-content">
            <h2>Import Database</h2>
            <p>Database import functionality will be implemented here.</p>

            <form method="post" enctype="multipart/form-data">
                <p><label for="file">Select SQL file:</label></p>
                <input type="file" name="file" accept=".sql,.csv" required>
                <br><br>
                <button type="submit" class="btn btn-success">Import</button>
            </form>
        </div>
        {% endblock %}
        """,
        breadcrumb="Database Management &gt; Import",
    )


# Register the `main` blueprint on the module-level app after all
# route decorators have been defined. Wrapping in try/except avoids
# noisy errors if this file is imported multiple times in tests.
try:
    app.register_blueprint(main_bp)
except AssertionError:
    # Already registered elsewhere; ignore
    pass

# Register optional feature blueprints on the module-level app
try:
    import cms as _cms

    if hasattr(_cms, "cms_bp"):
        try:
            app.register_blueprint(_cms.cms_bp)
        except AssertionError:
            pass
except Exception:
    pass

try:
    import forum as _forum

    if hasattr(_forum, "forum_bp"):
        try:
            app.register_blueprint(_forum.forum_bp)
        except AssertionError:
            pass
except Exception:
    pass

try:
    from monitoring_system import monitoring_bp

    try:
        app.register_blueprint(monitoring_bp)
    except AssertionError:
        pass
except Exception:
    pass

try:
    from monitoring_dashboard import init_monitoring_dashboard

    monitoring_dashboard_instance = init_monitoring_dashboard(app)
except Exception:
    pass

try:
    from api_versioning import init_api_versioning

    init_api_versioning(app)
except Exception:
    pass

try:
    from advanced_caching import init_advanced_caching

    init_advanced_caching(app)
except Exception:
    pass

try:
    from background_jobs import init_background_jobs

    init_background_jobs(app)
except Exception:
    pass

try:
    from oauth_auth import init_oauth_auth

    init_oauth_auth(app)
except Exception:
    pass

try:
    from request_tracing import init_request_tracing

    init_request_tracing(app)
except Exception:
    pass

try:
    # from routes_rbac import rbac_bp

    # try:
    #     app.register_blueprint(rbac_bp)
    # except (AssertionError, ValueError):
    #     pass
    pass
except Exception:
    pass

# SocketIO Event Handlers for Real-Time Features
@socketio.on("join_rcon")
def handle_join_rcon(data):
    """Join RCON room for a specific server."""
    server_id = data.get("server_id")
    user_id = session.get("user_id")

    if not user_id or not server_id:
        return {"error": "Authentication required"}

    # Check if user has access to this server
    user = db.session.get(User, user_id)
    server = db.session.get(Server, server_id)

    if not server or not user_can_edit_server(user, server):
        return {"error": "Access denied"}

    room = f"rcon_{server_id}"
    join_room(room)
    emit("joined_room", {"server_id": server_id, "server_name": server.name})


@socketio.on("leave_rcon")
def handle_leave_rcon(data):
    """Leave RCON room."""
    server_id = data.get("server_id")
    if server_id:
        room = f"rcon_{server_id}"
        leave_room(room)


@socketio.on("rcon_command")
def handle_rcon_command(data):
    """Execute RCON command and broadcast result."""
    server_id = data.get("server_id")
    command = data.get("command", "").strip()
    user_id = session.get("user_id")

    if not user_id or not server_id or not command:
        emit("rcon_error", {"message": "Invalid request"})
        return

    # Check permissions
    user = db.session.get(User, user_id)
    server = db.session.get(Server, server_id)

    if not server or not user_can_edit_server(user, server):
        emit("rcon_error", {"message": "Access denied"})
        return

    # Check server connection details
    if not server.host or not server.port or not server.rcon_password:
        emit("rcon_error", {"message": "Server connection not configured"})
        return

    try:
        from rcon_client import ETLegacyRcon

        rc = ETLegacyRcon.from_server(server)
        result = rc.send_command(command)

        # Broadcast to all users in this server's RCON room
        room = f"rcon_{server_id}"
        emit(
            "rcon_output",
            {
                "command": command,
                "output": result,
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "user": user.email,
            },
            room=room,
        )

        # Log the command
        db.session.add(
            AuditLog(actor_id=user.id, action=f"rcon_command:{server.name}:{command[:50]}")
        )
        db.session.commit()

    except Exception as e:
        emit("rcon_error", {"message": f"Command failed: {str(e)}"})


# Register blueprints after all routes are defined
try:
    app.register_blueprint(main_bp)
except (AssertionError, ValueError):
    # already registered
    pass

# Register optional feature blueprints (import here to avoid circular imports)
try:
    from routes_config import config_bp

    try:
        app.register_blueprint(config_bp)
    except (AssertionError, ValueError):
        pass
except Exception:
    pass

try:
    import cms as _cms

    if hasattr(_cms, "cms_bp"):
        try:
            app.register_blueprint(_cms.cms_bp)
        except (AssertionError, ValueError):
            pass
except Exception:
    pass

try:
    import forum as _forum

    if hasattr(_forum, "forum_bp"):
        try:
            app.register_blueprint(_forum.forum_bp)
        except (AssertionError, ValueError):
            pass
except Exception:
    pass

try:
    from monitoring_system import monitoring_bp

    try:
        app.register_blueprint(monitoring_bp)
    except AssertionError:
        pass
except Exception:
    pass

try:
    from monitoring_dashboard import init_monitoring_dashboard

    monitoring_dashboard_instance = init_monitoring_dashboard(app)
except Exception:
    pass

try:
    from api_versioning import init_api_versioning

    init_api_versioning(app)
except Exception:
    pass

try:
    from advanced_caching import init_advanced_caching

    init_advanced_caching(app)
except Exception:
    pass

try:
    from background_jobs import init_background_jobs

    init_background_jobs(app)
except Exception:
    pass

try:
    from oauth_auth import init_oauth_auth

    init_oauth_auth(app)
except Exception:
    pass

try:
    from request_tracing import init_request_tracing

    init_request_tracing(app)
except Exception:
    pass

try:
    # from routes_rbac import rbac_bp

    # try:
    #     app.register_blueprint(rbac_bp)
    # except (AssertionError, ValueError):
    #     pass
    pass
except Exception:
    pass
