"""
Advanced API Rate Limiting & Abuse Prevention
Implements sophisticated rate limiting with IP blocking, behavior analysis, and external integrations
"""

import logging
import time
import json
from collections import defaultdict, deque
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta

from flask import Flask, request, g
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

logger = logging.getLogger(__name__)


class IPBlocklist:
    """IP address blocklist management"""

    def __init__(self, redis_client=None):
        self.redis = redis_client
        self.local_blocklist = set()
        self.block_ttl = 3600  # 1 hour default

    def block_ip(self, ip: str, reason: str = "abuse", ttl: int = None) -> None:
        """Block an IP address"""
        if ttl is None:
            ttl = self.block_ttl

        if self.redis:
            key = f"blocked_ip:{ip}"
            self.redis.setex(key, ttl, json.dumps({
                "reason": reason,
                "blocked_at": datetime.utcnow().isoformat(),
                "ttl": ttl
            }))
        else:
            self.local_blocklist.add(ip)

        logger.warning(f"IP blocked: {ip} (reason: {reason})")

        # Trigger fail2ban if configured
        self._trigger_fail2ban(ip, reason)

    def unblock_ip(self, ip: str) -> None:
        """Unblock an IP address"""
        if self.redis:
            self.redis.delete(f"blocked_ip:{ip}")
        else:
            self.local_blocklist.discard(ip)

        logger.info(f"IP unblocked: {ip}")

    def is_blocked(self, ip: str) -> bool:
        """Check if IP is blocked"""
        if self.redis:
            return bool(self.redis.exists(f"blocked_ip:{ip}"))
        else:
            return ip in self.local_blocklist

    def _trigger_fail2ban(self, ip: str, reason: str) -> None:
        """Trigger fail2ban ban"""
        try:
            import subprocess
            # Use fail2ban-client to ban IP
            subprocess.run([
                "fail2ban-client", "set", "panel", "banip", ip
            ], capture_output=True, timeout=10)
            logger.info(f"Fail2ban ban triggered for IP: {ip}")
        except Exception as e:
            logger.warning(f"Fail2ban integration failed: {e}")


class BehaviorAnalyzer:
    """User behavior analysis for anomaly detection"""

    def __init__(self, redis_client=None, window_size: int = 3600):
        self.redis = redis_client
        self.window_size = window_size  # Analysis window in seconds
        self.request_history: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))

    def record_request(self, identifier: str, timestamp: float = None) -> None:
        """Record a request for behavior analysis"""
        if timestamp is None:
            timestamp = time.time()

        if self.redis:
            key = f"behavior:{identifier}"
            self.redis.zadd(key, {str(timestamp): timestamp})
            # Keep only recent entries
            self.redis.zremrangebyscore(key, 0, timestamp - self.window_size)
        else:
            self.request_history[identifier].append(timestamp)

    def get_request_rate(self, identifier: str, window: int = 60) -> float:
        """Get request rate per minute for the last window seconds"""
        now = time.time()
        window_start = now - window

        if self.redis:
            key = f"behavior:{identifier}"
            count = self.redis.zcount(key, window_start, now)
            return (count / window) * 60  # requests per minute
        else:
            recent_requests = [t for t in self.request_history[identifier] if t > window_start]
            return (len(recent_requests) / window) * 60

    def detect_anomaly(self, identifier: str, current_rate: float, threshold: float = 10.0) -> bool:
        """Detect anomalous behavior based on request rate"""
        # Simple threshold-based anomaly detection
        # In production, this could use statistical methods or ML
        return current_rate > threshold

    def get_behavior_stats(self, identifier: str) -> Dict[str, float]:
        """Get behavior statistics for an identifier"""
        return {
            "rate_1min": self.get_request_rate(identifier, 60),
            "rate_5min": self.get_request_rate(identifier, 300),
            "rate_15min": self.get_request_rate(identifier, 900),
        }


class CloudflareIntegration:
    """Cloudflare API integration for DDoS protection"""

    def __init__(self, api_token: str = None, zone_id: str = None):
        self.api_token = api_token
        self.zone_id = zone_id
        self.base_url = "https://api.cloudflare.com/client/v4"

    def block_ip(self, ip: str, reason: str = "abuse") -> bool:
        """Block IP using Cloudflare firewall rules"""
        if not all([self.api_token, self.zone_id]):
            logger.warning("Cloudflare not configured, skipping IP block")
            return False

        try:
            import requests

            headers = {
                "Authorization": f"Bearer {self.api_token}",
                "Content-Type": "application/json"
            }

            # Create firewall rule to block IP
            rule_data = {
                "filter": {
                    "expression": f"ip.src eq {ip}"
                },
                "action": "block",
                "description": f"Panel abuse prevention: {reason}"
            }

            response = requests.post(
                f"{self.base_url}/zones/{self.zone_id}/firewall/rules",
                headers=headers,
                json=rule_data,
                timeout=10
            )

            if response.status_code == 200:
                logger.info(f"Cloudflare IP block successful: {ip}")
                return True
            else:
                logger.error(f"Cloudflare API error: {response.text}")
                return False

        except Exception as e:
            logger.error(f"Cloudflare integration error: {e}")
            return False

    def get_blocked_ips(self) -> List[str]:
        """Get list of blocked IPs from Cloudflare"""
        if not all([self.api_token, self.zone_id]):
            return []

        try:
            import requests

            headers = {
                "Authorization": f"Bearer {self.api_token}",
                "Content-Type": "application/json"
            }

            response = requests.get(
                f"{self.base_url}/zones/{self.zone_id}/firewall/rules",
                headers=headers,
                timeout=10
            )

            if response.status_code == 200:
                rules = response.json().get("result", [])
                blocked_ips = []
                for rule in rules:
                    if rule.get("action") == "block":
                        # Extract IP from filter expression
                        expression = rule.get("filter", {}).get("expression", "")
                        if "ip.src eq" in expression:
                            ip = expression.split("ip.src eq")[1].strip()
                            blocked_ips.append(ip)
                return blocked_ips
            else:
                logger.error(f"Cloudflare API error: {response.text}")
                return []

        except Exception as e:
            logger.error(f"Cloudflare integration error: {e}")
            return []


class AdvancedRateLimiter:
    """Advanced rate limiter with abuse prevention"""

    def __init__(self, app: Flask):
        self.app = app
        self.redis = None
        self.ip_blocklist = None
        self.behavior_analyzer = None
        self.cloudflare = None

        # Configuration
        self.abuse_threshold = float(app.config.get('RATE_LIMIT_ABUSE_THRESHOLD', '10.0'))
        self.block_duration = int(app.config.get('RATE_LIMIT_BLOCK_DURATION', '3600'))

        # Initialize components
        self._init_components()

    def _init_components(self) -> None:
        """Initialize all components"""
        try:
            from src.panel.services.cache_service import get_cache_service
            cache = get_cache_service()
            if hasattr(cache, '_cache') and hasattr(cache._cache, 'connection'):
                self.redis = cache._cache.connection
        except Exception:
            logger.warning("Redis not available for advanced rate limiting")

        self.ip_blocklist = IPBlocklist(self.redis)
        self.behavior_analyzer = BehaviorAnalyzer(self.redis)

        # Cloudflare integration
        cf_token = self.app.config.get('CLOUDFLARE_API_TOKEN')
        cf_zone = self.app.config.get('CLOUDFLARE_ZONE_ID')
        if cf_token and cf_zone:
            self.cloudflare = CloudflareIntegration(cf_token, cf_zone)
            logger.info("Cloudflare integration enabled")
        else:
            logger.info("Cloudflare integration disabled (missing config)")

    def check_request(self) -> Tuple[bool, Optional[str]]:
        """
        Check if request should be allowed
        Returns: (allowed, reason_if_blocked)
        """
        ip = get_remote_address()
        user_id = getattr(g, 'user_id', None)
        identifier = user_id or f"ip:{ip}"

        # Check if IP is blocked
        if self.ip_blocklist.is_blocked(ip):
            return False, "IP address blocked"

        # Record request for behavior analysis
        self.behavior_analyzer.record_request(identifier)

        # Check for anomalous behavior
        current_rate = self.behavior_analyzer.get_request_rate(identifier, 60)
        if self.behavior_analyzer.detect_anomaly(identifier, current_rate, self.abuse_threshold):
            # Block the IP
            reason = f"Anomalous behavior detected (rate: {current_rate:.1f} req/min)"
            self.block_ip(ip, reason)
            return False, reason

        return True, None

    def block_ip(self, ip: str, reason: str = "abuse") -> None:
        """Block an IP address using all available methods"""
        self.ip_blocklist.block_ip(ip, reason, self.block_duration)

        # Cloudflare integration
        if self.cloudflare:
            self.cloudflare.block_ip(ip, reason)

    def unblock_ip(self, ip: str) -> None:
        """Unblock an IP address"""
        self.ip_blocklist.unblock_ip(ip)

    def get_stats(self) -> Dict[str, any]:
        """Get rate limiting statistics"""
        return {
            "blocked_ips_count": len(self.ip_blocklist.local_blocklist) if not self.redis else "redis-backed",
            "cloudflare_enabled": self.cloudflare is not None,
            "abuse_threshold": self.abuse_threshold,
            "block_duration": self.block_duration,
        }


def get_user_id_or_ip():
    """Get user ID if logged in, otherwise use IP address for rate limiting"""
    from flask import session
    return session.get("user_id", get_remote_address())


def get_rate_limit_by_role():
    """Get rate limit based on user role"""
    from flask import session

    user_id = session.get("user_id")
    if user_id:
        try:
            from src.panel import db
            from src.panel.models import User
            user = db.session.get(User, user_id)
            if user and user.is_system_admin():
                return "1000 per hour"
            elif user and user.is_admin:
                return "500 per hour"
        except Exception:
            pass

    return "200 per hour"


def setup_rate_limiting(app: Flask):
    """
    Configure advanced rate limiting with abuse prevention
    """

    # Initialize advanced rate limiter
    advanced_limiter = AdvancedRateLimiter(app)

    # Standard Flask-Limiter setup
    limiter = Limiter(
        app=app,
        key_func=get_user_id_or_ip,
        default_limits=["200 per hour"],
        storage_uri=app.config.get("REDIS_URL", "redis://127.0.0.1:6379/0"),
        storage_options={"socket_connect_timeout": 30},
        strategy="fixed-window",
        headers_enabled=True,
    )

    # Enhanced error handler
    @app.errorhandler(429)
    def ratelimit_handler(e):
        ip = get_remote_address()
        logger.warning(f"Rate limit exceeded for {ip}: {e.description}")

        # Check if this is abusive behavior
        allowed, reason = advanced_limiter.check_request()
        if not allowed and "Anomalous" in (reason or ""):
            # This was already handled in check_request
            pass

        return {
            "error": "Rate limit exceeded",
            "message": str(e.description),
            "retry_after": getattr(e, 'retry_after', 3600)
        }, 429

    # Request middleware for abuse prevention
    @app.before_request
    def check_abuse_prevention():
        if request.endpoint in ['static', 'health', 'metrics']:
            return  # Skip checks for static/health endpoints

        allowed, reason = advanced_limiter.check_request()
        if not allowed:
            logger.warning(f"Request blocked: {get_remote_address()} - {reason}")
            return {
                "error": "Access denied",
                "message": reason or "Request blocked"
            }, 403

    # Specific limits for sensitive endpoints
    limiter.limit("5 per minute")(app.view_functions.get('login', lambda: None))
    limiter.limit("3 per minute")(app.view_functions.get('register', lambda: None))
    limiter.limit("2 per minute")(app.view_functions.get('forgot', lambda: None))
    limiter.limit("10 per hour")(app.view_functions.get('reset', lambda: None))

    # API endpoints
    limiter.limit("30 per minute", key_func=get_user_id_or_ip)(app.view_functions.get('api_get_tokens', lambda: None))
    limiter.limit("100 per hour", key_func=get_user_id_or_ip)(app.view_functions.get('api_health', lambda: None))

    # Admin endpoints
    limiter.limit(get_rate_limit_by_role, key_func=get_user_id_or_ip)(app.view_functions.get('teams_dashboard', lambda: None))
    limiter.limit(get_rate_limit_by_role, key_func=get_user_id_or_ip)(app.view_functions.get('security_dashboard', lambda: None))
    limiter.limit("50 per hour", key_func=get_user_id_or_ip)(app.view_functions.get('admin_users', lambda: None))

    # Server management
    limiter.limit("20 per minute", key_func=get_user_id_or_ip)(app.view_functions.get('server_create', lambda: None))
    limiter.limit("50 per hour", key_func=get_user_id_or_ip)(app.view_functions.get('server_edit', lambda: None))

    # Forum endpoints
    limiter.limit("60 per minute", key_func=get_user_id_or_ip)(app.view_functions.get('forum_index', lambda: None))
    limiter.limit("10 per minute", key_func=get_user_id_or_ip)(app.view_functions.get('create_thread', lambda: None))
    limiter.limit("30 per minute", key_func=get_user_id_or_ip)(app.view_functions.get('post_reply', lambda: None))

    # CMS endpoints
    limiter.limit("30 per minute", key_func=get_user_id_or_ip)(app.view_functions.get('blog_index', lambda: None))
    limiter.limit("5 per hour", key_func=get_user_id_or_ip)(app.view_functions.get('create_post', lambda: None))

    # Store advanced limiter in app for access
    app.advanced_limiter = advanced_limiter

    logger.info("Advanced rate limiting and abuse prevention enabled")

    return limiter


# Admin endpoints for rate limiting management
def init_rate_limiting_admin(app: Flask):
    """Initialize admin endpoints for rate limiting management"""

    @app.route('/admin/rate-limiting/stats')
    @auth_admin_required
    def rate_limiting_stats():
        """Get rate limiting statistics"""
        limiter = getattr(app, 'advanced_limiter', None)
        if not limiter:
            return jsonify({"error": "Advanced rate limiter not initialized"}), 500

        return jsonify(limiter.get_stats())

    @app.route('/admin/rate-limiting/block/<ip>', methods=['POST'])
    @auth_admin_required
    def block_ip_admin(ip):
        """Manually block an IP"""
        limiter = getattr(app, 'advanced_limiter', None)
        if not limiter:
            return jsonify({"error": "Advanced rate limiter not initialized"}), 500

        limiter.block_ip(ip, "manual_admin_block")
        return jsonify({"status": "IP blocked", "ip": ip})

    @app.route('/admin/rate-limiting/unblock/<ip>', methods=['POST'])
    @auth_admin_required
    def unblock_ip_admin(ip):
        """Manually unblock an IP"""
        limiter = getattr(app, 'advanced_limiter', None)
        if not limiter:
            return jsonify({"error": "Advanced rate limiter not initialized"}), 500

        limiter.unblock_ip(ip)
        return jsonify({"status": "IP unblocked", "ip": ip})
