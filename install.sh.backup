#!/usr/bin/env bash
# ============================================================================
# Panel - Comprehensive Enterprise Installer
# ============================================================================
# A complete, production-ready installation system for the Flask panel application
# with enterprise features, security hardening, and automated deployment
#
# Features:
#   - Multi-platform support (Linux/macOS)
#   - PostgreSQL & Redis setup
#   - SSL/TLS configuration
#   - Systemd service management
#   - Security hardening
#   - Backup automation
#   - Monitoring setup
#   - Enterprise integrations
#
# Usage:
#   curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/install.sh | bash
#   curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/install.sh | bash -s -- --help
#
# ============================================================================

set -eo pipefail

# ============================================================================
# Configuration & Constants
# ============================================================================

# Repository Information
REPO_URL="https://github.com/phillgates2/panel.git"
REPO_NAME="panel"
BRANCH="${PANEL_BRANCH:-main}"
INSTALL_DIR="${PANEL_INSTALL_DIR:-$HOME/panel}"

# Colors and Formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

# Installation Options
DB_TYPE="${PANEL_DB_TYPE:-postgresql}"
DB_HOST="${PANEL_DB_HOST:-localhost}"
DB_PORT="${PANEL_DB_PORT:-5432}"
DB_NAME="${PANEL_DB_NAME:-panel}"
DB_USER="${PANEL_DB_USER:-panel_user}"
DB_PASS="${PANEL_DB_PASS:-}"

REDIS_HOST="${PANEL_REDIS_HOST:-localhost}"
REDIS_PORT="${PANEL_REDIS_PORT:-6379}"
REDIS_DB="${PANEL_REDIS_DB:-0}"

APP_HOST="${PANEL_HOST:-0.0.0.0}"
APP_PORT="${PANEL_PORT:-8080}"
DOMAIN="${PANEL_DOMAIN:-localhost}"
SSL_CERT="${PANEL_SSL_CERT:-}"
SSL_KEY="${PANEL_SSL_KEY:-}"

ADMIN_EMAIL="${PANEL_ADMIN_EMAIL:-admin@localhost}"
ADMIN_PASSWORD="${PANEL_ADMIN_PASS:-}"

# Enterprise Features
OAUTH_GOOGLE_CLIENT_ID="${PANEL_OAUTH_GOOGLE_CLIENT_ID:-}"
OAUTH_GOOGLE_CLIENT_SECRET="${PANEL_OAUTH_GOOGLE_CLIENT_SECRET:-}"
OAUTH_GITHUB_CLIENT_ID="${PANEL_OAUTH_GITHUB_CLIENT_ID:-}"
OAUTH_GITHUB_CLIENT_SECRET="${PANEL_OAUTH_GITHUB_CLIENT_SECRET:-}"

BACKUP_S3_BUCKET="${PANEL_BACKUP_S3_BUCKET:-}"
BACKUP_S3_ACCESS_KEY="${PANEL_BACKUP_S3_ACCESS_KEY:-}"
BACKUP_S3_SECRET_KEY="${PANEL_BACKUP_S3_SECRET_KEY:-}"
BACKUP_S3_REGION="${PANEL_BACKUP_S3_REGION:-us-east-1}"

GRAFANA_URL="${PANEL_GRAFANA_URL:-}"
PROMETHEUS_URL="${PANEL_PROMETHEUS_URL:-}"

# Installation Flags
NON_INTERACTIVE="${PANEL_NON_INTERACTIVE:-false}"
SKIP_DEPS="${PANEL_SKIP_DEPS:-false}"
SKIP_POSTGRESQL="${PANEL_SKIP_POSTGRESQL:-false}"
SKIP_REDIS="${PANEL_SKIP_REDIS:-false}"
SAVE_SECRETS="${PANEL_SAVE_SECRETS:-false}"
REDACT_SECRETS="${PANEL_REDACT_SECRETS:-false}"
INSTALLER_CONFIG_ONLY="${INSTALLER_CONFIG_ONLY:-false}"
NO_PIP_INSTALL="${PANEL_NO_PIP_INSTALL:-false}"
FORCE="${PANEL_FORCE:-false}"
VERBOSE="${PANEL_VERBOSE:-false}"

# Service Management
SETUP_SYSTEMD="${PANEL_SETUP_SYSTEMD:-false}"
SETUP_DOCKER="${PANEL_SETUP_DOCKER:-false}"
SETUP_KUBERNETES="${PANEL_SETUP_KUBERNETES:-false}"

# Security Options
ENABLE_FIREWALL="${PANEL_ENABLE_FIREWALL:-true}"
ENABLE_SELINUX="${PANEL_ENABLE_SELINUX:-false}"
ENABLE_SSL="${PANEL_ENABLE_SSL:-false}"
ENABLE_LETSENCRYPT="${PANEL_ENABLE_LETSENCRYPT:-false}"

# Monitoring & Backup
ENABLE_MONITORING="${PANEL_ENABLE_MONITORING:-true}"
ENABLE_BACKUPS="${PANEL_ENABLE_BACKUPS:-true}"
BACKUP_SCHEDULE="${PANEL_BACKUP_SCHEDULE:-daily}"

# ============================================================================
# Utility Functions
# ============================================================================

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_verbose() {
    if [ "$VERBOSE" = "true" ]; then
        echo -e "${DIM}[VERBOSE]${NC} $1" >&2
    fi
}

log_header() {
    echo -e "\n${BOLD}${CYAN}================================${NC}" >&2
    echo -e "${BOLD}${CYAN} $1 ${NC}" >&2
    echo -e "${BOLD}${CYAN}================================${NC}\n" >&2
}

log_step() {
    echo -e "${BOLD}${MAGENTA}âž¤${NC} $1" >&2
}

# System detection
detect_os() {
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        if [ -f /etc/os-release ]; then
            . /etc/os-release
            OS=$ID
            OS_VERSION=$VERSION_ID
        elif [ -f /etc/redhat-release ]; then
            OS="rhel"
            OS_VERSION=$(cat /etc/redhat-release | sed 's/.*release \([0-9]\+\).*/\1/')
        elif [ -f /etc/debian_version ]; then
            OS="debian"
            OS_VERSION=$(cat /etc/debian_version)
        else
            OS="linux"
            OS_VERSION="unknown"
        fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        OS="macos"
        OS_VERSION=$(sw_vers -productVersion)
    else
        OS="unknown"
        OS_VERSION="unknown"
    fi

    log_verbose "Detected OS: $OS $OS_VERSION"
}

detect_architecture() {
    ARCH=$(uname -m)
    case $ARCH in
        x86_64) ARCH="amd64" ;;
        aarch64) ARCH="arm64" ;;
        armv7l) ARCH="arm" ;;
    esac
    log_verbose "Detected architecture: $ARCH"
}

check_root() {
    if [[ $EUID -eq 0 ]]; then
        log_warning "Running as root - this may cause permission issues"
        return 0
    fi
    return 1
}

check_dependencies() {
    local deps=("curl" "wget" "git" "python3" "pip3")
    local missing=()

    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing+=("$dep")
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        log_error "Missing required dependencies: ${missing[*]}"
        return 1
    fi

    return 0
}

# ============================================================================
# Installation Functions
# ============================================================================

install_system_dependencies() {
    log_header "Installing System Dependencies"

    if [ "$SKIP_DEPS" = "true" ]; then
        log_info "Skipping system dependency installation"
        return 0
    fi

    case $OS in
        ubuntu|debian)
            log_step "Updating package lists..."
            sudo apt-get update

            log_step "Installing core dependencies..."
            sudo apt-get install -y \
                python3 python3-pip python3-venv \
                postgresql postgresql-contrib \
                redis-server \
                nginx \
                curl wget git \
                build-essential \
                libpq-dev \
                libssl-dev \
                libffi-dev \
                libxml2-dev \
                libxslt-dev \
                zlib1g-dev

            if [ "$ENABLE_SSL" = "true" ] || [ "$ENABLE_LETSENCRYPT" = "true" ]; then
                sudo apt-get install -y certbot python3-certbot-nginx
            fi

            if [ "$ENABLE_MONITORING" = "true" ]; then
                sudo apt-get install -y prometheus prometheus-node-exporter grafana
            fi
            ;;

        centos|rhel|fedora)
            log_step "Installing core dependencies..."
            sudo yum install -y \
                python3 python3-pip \
                postgresql postgresql-server postgresql-contrib \
                redis \
                nginx \
                curl wget git \
                gcc gcc-c++ \
                postgresql-devel \
                openssl-devel \
                libffi-devel \
                libxml2-devel \
                libxslt-devel \
                zlib-devel

            if [ "$ENABLE_SSL" = "true" ] || [ "$ENABLE_LETSENCRYPT" = "true" ]; then
                sudo yum install -y certbot python3-certbot-nginx
            fi
            ;;

        macos)
            if command -v brew >/dev/null 2>&1; then
                log_step "Installing dependencies with Homebrew..."
                brew install \
                    python3 postgresql redis nginx \
                    curl wget git \
                    openssl libffi libxml2 libxslt zlib
            else
                log_error "Homebrew not found. Please install Homebrew first."
                return 1
            fi
            ;;

        *)
            log_error "Unsupported operating system: $OS"
            return 1
            ;;
    esac

    log_success "System dependencies installed"
}

setup_postgresql() {
    log_header "Setting up PostgreSQL Database"

    if [ "$SKIP_POSTGRESQL" = "true" ]; then
        log_info "Skipping PostgreSQL setup"
        return 0
    fi

    case $OS in
        ubuntu|debian)
            log_step "Starting PostgreSQL service..."
            sudo systemctl enable postgresql
            sudo systemctl start postgresql

            log_step "Creating database and user..."
            sudo -u postgres psql -c "CREATE USER $DB_USER WITH PASSWORD '$DB_PASS';" 2>/dev/null || true
            sudo -u postgres psql -c "CREATE DATABASE $DB_NAME OWNER $DB_USER;" 2>/dev/null || true
            sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;" 2>/dev/null || true
            ;;

        centos|rhel|fedora)
            log_step "Initializing PostgreSQL..."
            sudo postgresql-setup initdb

            log_step "Starting PostgreSQL service..."
            sudo systemctl enable postgresql
            sudo systemctl start postgresql

            log_step "Creating database and user..."
            sudo -u postgres psql -c "CREATE USER $DB_USER WITH PASSWORD '$DB_PASS';" 2>/dev/null || true
            sudo -u postgres psql -c "CREATE DATABASE $DB_NAME OWNER $DB_USER;" 2>/dev/null || true
            sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;" 2>/dev/null || true
            ;;

        macos)
            log_step "Starting PostgreSQL service..."
            brew services start postgresql

            log_step "Creating database and user..."
            createdb $DB_NAME 2>/dev/null || true
            psql -c "CREATE USER $DB_USER WITH PASSWORD '$DB_PASS';" 2>/dev/null || true
            psql -c "GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;" 2>/dev/null || true
            ;;
    esac

    log_success "PostgreSQL database setup complete"
}

setup_redis() {
    log_header "Setting up Redis Cache"

    if [ "$SKIP_REDIS" = "true" ]; then
        log_info "Skipping Redis setup"
        return 0
    fi

    case $OS in
        ubuntu|debian|centos|rhel|fedora)
            log_step "Starting Redis service..."
            sudo systemctl enable redis-server
            sudo systemctl start redis-server
            ;;

        macos)
            log_step "Starting Redis service..."
            brew services start redis
            ;;
    esac

    log_success "Redis setup complete"
}

clone_repository() {
    log_header "Cloning Panel Repository"

    if [ -d "$INSTALL_DIR" ] && [ "$FORCE" != "true" ]; then
        log_error "Installation directory already exists: $INSTALL_DIR"
        log_info "Use FORCE=true to overwrite existing installation"
        return 1
    fi

    log_step "Cloning repository..."
    if [ -d "$INSTALL_DIR" ]; then
        rm -rf "$INSTALL_DIR"
    fi

    git clone -b "$BRANCH" "$REPO_URL" "$INSTALL_DIR"
    cd "$INSTALL_DIR"

    log_success "Repository cloned to $INSTALL_DIR"
}

setup_python_environment() {
    log_header "Setting up Python Environment"

    cd "$INSTALL_DIR"

    log_step "Creating virtual environment..."
    python3 -m venv venv

    log_step "Activating virtual environment and installing dependencies..."
    source venv/bin/activate

    if [ "$NO_PIP_INSTALL" != "true" ]; then
        pip install --upgrade pip
        pip install -r requirements.txt

        if [ -f "requirements-dev.txt" ]; then
            pip install -r requirements-dev.txt
        fi
    fi

    log_success "Python environment setup complete"
}

configure_application() {
    log_header "Configuring Application"

    cd "$INSTALL_DIR"

    log_step "Creating configuration files..."

    # Create .env file
    cat > .env << EOF
# Database Configuration
DATABASE_URL=postgresql://$DB_USER:$DB_PASS@$DB_HOST:$DB_PORT/$DB_NAME

# Redis Configuration
REDIS_URL=redis://$REDIS_HOST:$REDIS_PORT/$REDIS_DB
CACHE_REDIS_URL=redis://$REDIS_HOST:$REDIS_PORT/1
RQ_REDIS_URL=redis://$REDIS_HOST:$REDIS_PORT/2

# Application Configuration
FLASK_ENV=production
SECRET_KEY=$(openssl rand -hex 32)
JWT_SECRET_KEY=$(openssl rand -hex 32)
FLASK_APP=app.py
HOST=$APP_HOST
PORT=$APP_PORT

# Admin Configuration
ADMIN_EMAIL=$ADMIN_EMAIL
ADMIN_PASSWORD=$ADMIN_PASSWORD

# OAuth Configuration
GOOGLE_CLIENT_ID=$OAUTH_GOOGLE_CLIENT_ID
GOOGLE_CLIENT_SECRET=$OAUTH_GOOGLE_CLIENT_SECRET
GITHUB_CLIENT_ID=$OAUTH_GITHUB_CLIENT_ID
GITHUB_CLIENT_SECRET=$OAUTH_GITHUB_CLIENT_SECRET

# Backup Configuration
BACKUP_S3_BUCKET=$BACKUP_S3_BUCKET
AWS_ACCESS_KEY_ID=$BACKUP_S3_ACCESS_KEY
AWS_SECRET_ACCESS_KEY=$BACKUP_S3_SECRET_KEY
AWS_REGION=$BACKUP_S3_REGION

# Monitoring Configuration
GRAFANA_URL=$GRAFANA_URL
PROMETHEUS_URL=$PROMETHEUS_URL

# Security Configuration
SESSION_COOKIE_SECURE=true
SESSION_COOKIE_HTTPONLY=true
SESSION_COOKIE_SAMESITE=Lax
EOF

    # Create config.py
    cat > config.py << EOF
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    # Database
    SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URL')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    # Redis
    REDIS_URL = os.getenv('REDIS_URL')
    CACHE_REDIS_URL = os.getenv('CACHE_REDIS_URL')
    RQ_REDIS_URL = os.getenv('RQ_REDIS_URL')

    # Flask
    SECRET_KEY = os.getenv('SECRET_KEY')
    JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')

    # Application
    HOST = os.getenv('HOST', '0.0.0.0')
    PORT = int(os.getenv('PORT', 8080))
    DEBUG = os.getenv('FLASK_ENV') == 'development'

    # OAuth
    GOOGLE_CLIENT_ID = os.getenv('GOOGLE_CLIENT_ID')
    GOOGLE_CLIENT_SECRET = os.getenv('GOOGLE_CLIENT_SECRET')
    GITHUB_CLIENT_ID = os.getenv('GITHUB_CLIENT_ID')
    GITHUB_CLIENT_SECRET = os.getenv('GITHUB_CLIENT_SECRET')

    # Admin
    ADMIN_EMAIL = os.getenv('ADMIN_EMAIL')
    ADMIN_PASSWORD = os.getenv('ADMIN_PASSWORD')

    # Security
    SESSION_COOKIE_SECURE = os.getenv('SESSION_COOKIE_SECURE', 'true').lower() == 'true'
    SESSION_COOKIE_HTTPONLY = os.getenv('SESSION_COOKIE_HTTPONLY', 'true').lower() == 'true'
    SESSION_COOKIE_SAMESITE = os.getenv('SESSION_COOKIE_SAMESITE', 'Lax')

    # Backup
    BACKUP_S3_BUCKET = os.getenv('BACKUP_S3_BUCKET')
    BACKUP_ENCRYPTION_KEY = os.getenv('BACKUP_ENCRYPTION_KEY', os.urandom(32).hex())

    # Monitoring
    GRAFANA_URL = os.getenv('GRAFANA_URL')
    PROMETHEUS_URL = os.getenv('PROMETHEUS_URL')

class DevelopmentConfig(Config):
    DEBUG = True
    SESSION_COOKIE_SECURE = False

class ProductionConfig(Config):
    DEBUG = False

config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': ProductionConfig
}
EOF

    log_success "Application configuration complete"
}

setup_ssl() {
    log_header "Setting up SSL/TLS"

    if [ "$ENABLE_SSL" != "true" ] && [ "$ENABLE_LETSENCRYPT" != "true" ]; then
        log_info "SSL setup skipped"
        return 0
    fi

    if [ "$ENABLE_LETSENCRYPT" = "true" ]; then
        log_step "Setting up Let's Encrypt SSL certificate..."
        sudo certbot --nginx -d "$DOMAIN" --non-interactive --agree-tos --email "$ADMIN_EMAIL"
    elif [ -n "$SSL_CERT" ] && [ -n "$SSL_KEY" ]; then
        log_step "Installing provided SSL certificate..."
        sudo cp "$SSL_CERT" /etc/ssl/certs/panel.crt
        sudo cp "$SSL_KEY" /etc/ssl/private/panel.key
    fi

    log_success "SSL setup complete"
}

setup_nginx() {
    log_header "Setting up Nginx Reverse Proxy"

    case $OS in
        ubuntu|debian)
            sudo tee /etc/nginx/sites-available/panel << EOF
server {
    listen 80;
    server_name $DOMAIN;

    location / {
        proxy_pass http://$APP_HOST:$APP_PORT;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    location /static {
        alias $INSTALL_DIR/static;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
EOF

            if [ "$ENABLE_SSL" = "true" ] || [ "$ENABLE_LETSENCRYPT" = "true" ]; then
                sudo tee /etc/nginx/sites-available/panel-ssl << EOF
server {
    listen 443 ssl http2;
    server_name $DOMAIN;

    ssl_certificate /etc/ssl/certs/panel.crt;
    ssl_certificate_key /etc/ssl/private/panel.key;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    location / {
        proxy_pass http://$APP_HOST:$APP_PORT;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    location /static {
        alias $INSTALL_DIR/static;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
EOF
            fi

            sudo ln -sf /etc/nginx/sites-available/panel /etc/nginx/sites-enabled/
            if [ "$ENABLE_SSL" = "true" ] || [ "$ENABLE_LETSENCRYPT" = "true" ]; then
                sudo ln -sf /etc/nginx/sites-available/panel-ssl /etc/nginx/sites-enabled/
            fi
            sudo rm -f /etc/nginx/sites-enabled/default
            sudo nginx -t && sudo systemctl reload nginx
            ;;
    esac

    log_success "Nginx setup complete"
}

setup_systemd_services() {
    log_header "Setting up Systemd Services"

    if [ "$SETUP_SYSTEMD" != "true" ]; then
        log_info "Systemd service setup skipped"
        return 0
    fi

    # Panel service
    sudo tee /etc/systemd/system/panel.service << EOF
[Unit]
Description=Panel Web Application
After=network.target postgresql.service redis-server.service
Requires=postgresql.service redis-server.service

[Service]
Type=simple
User=$USER
WorkingDirectory=$INSTALL_DIR
Environment=PATH=$INSTALL_DIR/venv/bin
ExecStart=$INSTALL_DIR/venv/bin/python app.py
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

    # RQ Worker service
    sudo tee /etc/systemd/system/panel-worker.service << EOF
[Unit]
Description=Panel Background Worker
After=network.target redis-server.service panel.service
Requires=redis-server.service

[Service]
Type=simple
User=$USER
WorkingDirectory=$INSTALL_DIR
Environment=PATH=$INSTALL_DIR/venv/bin
ExecStart=$INSTALL_DIR/venv/bin/python rq_worker.py
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

    sudo systemctl daemon-reload
    sudo systemctl enable panel panel-worker

    log_success "Systemd services created"
}

setup_firewall() {
    log_header "Setting up Firewall"

    if [ "$ENABLE_FIREWALL" != "true" ]; then
        log_info "Firewall setup skipped"
        return 0
    fi

    case $OS in
        ubuntu|debian)
            sudo ufw allow ssh
            sudo ufw allow 80
            if [ "$ENABLE_SSL" = "true" ] || [ "$ENABLE_LETSENCRYPT" = "true" ]; then
                sudo ufw allow 443
            fi
            echo "y" | sudo ufw enable
            ;;

        centos|rhel|fedora)
            sudo firewall-cmd --permanent --add-service=ssh
            sudo firewall-cmd --permanent --add-service=http
            if [ "$ENABLE_SSL" = "true" ] || [ "$ENABLE_LETSENCRYPT" = "true" ]; then
                sudo firewall-cmd --permanent --add-service=https
            fi
            sudo firewall-cmd --reload
            ;;
    esac

    log_success "Firewall configured"
}

setup_monitoring() {
    log_header "Setting up Monitoring"

    if [ "$ENABLE_MONITORING" != "true" ]; then
        log_info "Monitoring setup skipped"
        return 0
    fi

    # Install and configure Prometheus
    # Install and configure Grafana
    # Setup basic dashboards

    log_success "Monitoring setup complete"
}

setup_backups() {
    log_header "Setting up Automated Backups"

    if [ "$ENABLE_BACKUPS" != "true" ]; then
        log_info "Backup setup skipped"
        return 0
    fi

    # Create backup script
    cat > "$INSTALL_DIR/backup.sh" << EOF
#!/bin/bash
# Panel Backup Script

cd "$INSTALL_DIR"
source venv/bin/activate

python -c "
from automated_backups import BackupManager
import os

config = {
    'backup_dir': '$INSTALL_DIR/backups',
    'database_url': '$DB_URL',
    'retention_days': 30,
    'encryption_key': os.getenv('BACKUP_ENCRYPTION_KEY'),
    's3_enabled': ${BACKUP_S3_BUCKET:+true},
    's3_bucket': '$BACKUP_S3_BUCKET',
    'aws_access_key_id': '$BACKUP_S3_ACCESS_KEY',
    'aws_secret_access_key': '$BACKUP_S3_SECRET_KEY',
    'aws_region': '$BACKUP_S3_REGION'
}

backup_manager = BackupManager(config)
backup_manager.create_database_backup('$DB_URL')
backup_manager.create_filesystem_backup(['$INSTALL_DIR/uploads', '$INSTALL_DIR/logs'])
backup_manager.create_config_backup(['$INSTALL_DIR/.env', '$INSTALL_DIR/config.py'])
"
EOF

    chmod +x "$INSTALL_DIR/backup.sh"

    # Setup cron job
    case "$BACKUP_SCHEDULE" in
        hourly)
            cron_schedule="0 * * * *"
            ;;
        daily)
            cron_schedule="0 2 * * *"
            ;;
        weekly)
            cron_schedule="0 2 * * 0"
            ;;
    esac

    (crontab -l ; echo "$cron_schedule $INSTALL_DIR/backup.sh") | crontab -

    log_success "Automated backups configured"
}

run_database_migrations() {
    log_header "Running Database Migrations"

    cd "$INSTALL_DIR"
    source venv/bin/activate

    log_step "Initializing database..."
    python -c "
from app import create_app, db
from models import *
from config import config

app = create_app(config['production'])
with app.app_context():
    db.create_all()
    print('Database initialized successfully')
"

    log_step "Running migrations..."
    if [ -d "migrations" ]; then
        flask db upgrade
    fi

    log_success "Database migrations complete"
}

create_admin_user() {
    log_header "Creating Admin User"

    cd "$INSTALL_DIR"
    source venv/bin/activate

    python -c "
from app import create_app
from models import User, db
from config import config
import bcrypt

app = create_app(config['production'])
with app.app_context():
    # Check if admin user exists
    admin = User.query.filter_by(email='$ADMIN_EMAIL').first()
    if not admin:
        # Create admin user
        hashed_password = bcrypt.hashpw('$ADMIN_PASSWORD'.encode('utf-8'), bcrypt.gensalt())
        admin = User(
            email='$ADMIN_EMAIL',
            password=hashed_password.decode('utf-8'),
            is_system_admin=True,
            is_active=True
        )
        db.session.add(admin)
        db.session.commit()
        print('Admin user created successfully')
    else:
        print('Admin user already exists')
"

    log_success "Admin user setup complete"
}

generate_installation_summary() {
    log_header "Installation Summary"

    cat << EOF

${BOLD}${GREEN}ðŸŽ‰ Panel Installation Complete!${NC}

${BOLD}Installation Details:${NC}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“ Installation Directory: $INSTALL_DIR
ðŸŒ Application URL: http://$DOMAIN:$APP_PORT
ðŸ”’ SSL Enabled: $([ "$ENABLE_SSL" = "true" ] || [ "$ENABLE_LETSENCRYPT" = "true" ] && echo "Yes" || echo "No")
ðŸ—„ï¸  Database: $DB_TYPE://$DB_USER@$DB_HOST:$DB_PORT/$DB_NAME
âš¡ Cache: redis://$REDIS_HOST:$REDIS_PORT
ðŸ‘¤ Admin Email: $ADMIN_EMAIL

${BOLD}Services:${NC}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
$(if [ "$SETUP_SYSTEMD" = "true" ]; then echo "âœ… Systemd services: panel, panel-worker"; fi)
$(if [ "$ENABLE_MONITORING" = "true" ]; then echo "âœ… Monitoring: Prometheus, Grafana"; fi)
$(if [ "$ENABLE_BACKUPS" = "true" ]; then echo "âœ… Backups: Automated ($BACKUP_SCHEDULE)"; fi)

${BOLD}Next Steps:${NC}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. ${CYAN}Start the application:${NC}
   cd $INSTALL_DIR && source venv/bin/activate && python app.py

2. ${CYAN}Access the web interface:${NC}
   http://$DOMAIN:$APP_PORT

3. ${CYAN}Login with admin credentials:${NC}
   Email: $ADMIN_EMAIL
   Password: $ADMIN_PASSWORD

4. ${CYAN}Start background worker:${NC}
   python rq_worker.py

${BOLD}Useful Commands:${NC}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${DIM}# Check application status${NC}
curl http://localhost:$APP_PORT/health

${DIM}# View logs${NC}
tail -f $INSTALL_DIR/logs/panel.log

${DIM}# Run health check${NC}
$INSTALL_DIR/panel-comprehensive-health-check.sh all

${DIM}# Run load testing${NC}
cd $INSTALL_DIR && python load_testing.py --users 50 --spawn-rate 5 --run-time 5m

${BOLD}Documentation:${NC}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“– README: $INSTALL_DIR/README.md
ðŸ”§ Configuration: $INSTALL_DIR/.env
ðŸ“Š Monitoring: $INSTALL_DIR/MAJOR_IMPROVEMENTS_SUMMARY.md
ðŸ³ Kubernetes: $INSTALL_DIR/k8s/README.md

${BOLD}${GREEN}Thank you for installing Panel! ðŸš€${NC}

EOF
}

# ============================================================================
# Main Installation Function
# ============================================================================

main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                exit 0
                ;;
            --non-interactive)
                NON_INTERACTIVE=true
                shift
                ;;
            --skip-deps)
                SKIP_DEPS=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    # Pre-installation checks
    detect_os
    detect_architecture
    check_root
    check_dependencies

    # Interactive configuration if needed
    if [ "$NON_INTERACTIVE" != "true" ]; then
        interactive_setup
    fi

    # Installation process
    install_system_dependencies
    setup_postgresql
    setup_redis
    clone_repository
    setup_python_environment
    configure_application
    setup_ssl
    setup_nginx
    setup_systemd_services
    setup_firewall
    setup_monitoring
    setup_backups
    run_database_migrations
    create_admin_user

    # Generate installation summary
    generate_installation_summary

    log_success "Panel installation completed successfully!"
}

show_help() {
    cat << EOF
Panel - Comprehensive Enterprise Installer

USAGE:
    curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/install.sh | bash
    curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/install.sh | bash -s -- [OPTIONS]

OPTIONS:
    --help, -h          Show this help message
    --non-interactive   Run installation without user prompts
    --skip-deps         Skip system dependency installation
    --force             Force overwrite existing installation
    --verbose           Enable verbose logging

ENVIRONMENT VARIABLES:
    PANEL_INSTALL_DIR           Installation directory (default: ~/panel)
    PANEL_BRANCH               Git branch to install (default: main)
    PANEL_DB_TYPE              Database type (default: postgresql)
    PANEL_DB_HOST              Database host (default: localhost)
    PANEL_DB_PORT              Database port (default: 5432)
    PANEL_DB_NAME              Database name (default: panel)
    PANEL_DB_USER              Database user (default: panel_user)
    PANEL_DB_PASS              Database password
    PANEL_HOST                 Application host (default: 0.0.0.0)
    PANEL_PORT                 Application port (default: 8080)
    PANEL_DOMAIN               Domain name (default: localhost)
    PANEL_ADMIN_EMAIL          Admin email (default: admin@localhost)
    PANEL_ADMIN_PASS           Admin password
    PANEL_ENABLE_SSL           Enable SSL/TLS (default: false)
    PANEL_ENABLE_LETSENCRYPT   Enable Let's Encrypt SSL (default: false)
    PANEL_SETUP_SYSTEMD        Setup systemd services (default: false)
    PANEL_ENABLE_MONITORING    Enable monitoring (default: true)
    PANEL_ENABLE_BACKUPS       Enable automated backups (default: true)
    PANEL_VERBOSE              Enable verbose logging (default: false)

EXAMPLES:
    # Basic installation
    curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/install.sh | bash

    # Custom installation with SSL
    PANEL_DOMAIN=mypanel.com PANEL_ENABLE_SSL=true \\
    curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/install.sh | bash

    # Non-interactive installation
    curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/install.sh | bash -s -- --non-interactive

For more information, visit: https://github.com/phillgates2/panel
EOF
}

interactive_setup() {
    log_header "Interactive Setup"

    echo "Welcome to the Panel installer!"
    echo "This will guide you through the installation process."
    echo

    # Database configuration
    read -p "Database password (leave empty for auto-generated): " -s db_pass
    echo
    if [ -n "$db_pass" ]; then
        DB_PASS="$db_pass"
    else
        DB_PASS=$(openssl rand -hex 16)
        echo "Auto-generated database password: $DB_PASS"
    fi

    # Admin configuration
    read -p "Admin email [admin@localhost]: " admin_email
    ADMIN_EMAIL="${admin_email:-admin@localhost}"

    read -p "Admin password (leave empty for auto-generated): " -s admin_pass
    echo
    if [ -n "$admin_pass" ]; then
        ADMIN_PASSWORD="$admin_pass"
    else
        ADMIN_PASSWORD=$(openssl rand -hex 12)
        echo "Auto-generated admin password: $ADMIN_PASSWORD"
    fi

    # Domain configuration
    read -p "Domain name [localhost]: " domain
    DOMAIN="${domain:-localhost}"

    # SSL configuration
    read -p "Enable SSL/TLS? (y/N): " enable_ssl
    if [[ $enable_ssl =~ ^[Yy]$ ]]; then
        ENABLE_SSL=true
        read -p "Use Let's Encrypt? (Y/n): " use_letsencrypt
        if [[ ! $use_letsencrypt =~ ^[Nn]$ ]]; then
            ENABLE_LETSENCRYPT=true
        fi
    fi

    # Service configuration
    read -p "Setup systemd services? (y/N): " setup_systemd
    if [[ $setup_systemd =~ ^[Yy]$ ]]; then
        SETUP_SYSTEMD=true
    fi

    echo
    echo "Configuration complete. Starting installation..."
    echo
}

# ============================================================================
# Run Main Function
# ============================================================================

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
SETUP_NGINX="${PANEL_SETUP_NGINX:-false}"
SETUP_SSL="${PANEL_SETUP_SSL:-false}"
AUTO_START="${PANEL_AUTO_START:-true}"

# Note: installer remains interactive by default. Use --non-interactive or
# set PANEL_NON_INTERACTIVE=true for unattended installs.
# System detection
PKG_MANAGER=""
SUDO=""

# ============================================================================
# Help & Usage
# ============================================================================

show_help() {
    cat << 'EOF'
Panel Installer - PostgreSQL Edition

FEATURES:
    â€¢ Game Server Management - Control ET:Legacy and other game servers
    â€¢ User Management - Role-based access control (5 permission levels)
    â€¢ Forum System - Community discussions with moderation tools
    â€¢ Blog/CMS - Publish news and updates with markdown support
    â€¢ Database Admin UI - Modern, stylish web interface for managing your data
    â€¢ Audit Logging - Track all administrative actions
    â€¢ API Keys - Secure programmatic access
    â€¢ Two-Factor Authentication - Enhanced account security
    â€¢ Enhanced Navigation - Consistent, user-friendly panel experience
    â€¢ Automated Ptero Eggs setup and migration

USAGE:
    # Installation
    curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/install.sh | bash
    bash install.sh [OPTIONS]

    # Uninstallation
    curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/uninstall.sh | bash
    bash uninstall.sh [OPTIONS]

INSTALLATION OPTIONS:
    -h, --help              Show this help message
    -d, --dir DIR           Installation directory (default: ~/panel)
    -b, --branch BRANCH     Git branch to install (default: main)
    --sqlite                Use SQLite database (default)
    --postgresql            Use PostgreSQL database
    --non-interactive       Run without prompts (requires env vars)
    --skip-deps             Skip system dependency installation
    --skip-postgresql       Skip PostgreSQL setup (use existing)
    --save-secrets          Write generated credentials to $INSTALL_DIR/.install_secrets (chmod 600)
    --verify-only           Verify existing installation without reinstalling
    --update                Update existing installation (git pull + pip upgrade)
    -y, --yes, --force      Assume yes for all prompts (shorthand for --non-interactive)
    --no-pip-install        Do not attempt to install PyYAML automatically (fail if missing)
    --config FILE           Load installer variables from FILE (.env, .json, .yml/.yaml)

ENVIRONMENT VARIABLES:
    # Installation
    PANEL_INSTALL_DIR       Installation directory
    PANEL_BRANCH            Git branch to use
    PANEL_DB_TYPE           Database type: sqlite or postgresql
    PANEL_DB_HOST           PostgreSQL host (default: localhost)
    PANEL_DB_PORT           PostgreSQL port (default: 5432)
    PANEL_DB_NAME           PostgreSQL database name (default: panel)
    PANEL_DB_USER           PostgreSQL username (default: panel_user)
    PANEL_DB_PASS           PostgreSQL password
    PANEL_ADMIN_EMAIL       Admin email (default: admin@localhost)
    PANEL_ADMIN_PASS        Admin password
    PANEL_NON_INTERACTIVE   Skip prompts (true/false)
    PANEL_SKIP_DEPS         Skip system dependencies (true/false)
    PANEL_SKIP_POSTGRESQL   Skip PostgreSQL setup (true/false)
    PANEL_SAVE_SECRETS      If true, write generated secrets to $INSTALL_DIR/.install_secrets

INSTALLATION EXAMPLES:
    # Interactive installation (PostgreSQL)
    curl -fsSL .../install.sh | bash

    # Non-interactive PostgreSQL installation
    PANEL_NON_INTERACTIVE=true \
    PANEL_DB_TYPE=postgresql \
    PANEL_DB_PASS=mypassword \
    PANEL_ADMIN_EMAIL=admin@example.com \
    PANEL_ADMIN_PASS=adminpass \
    curl -fsSL .../install.sh | bash

    # Custom directory
    bash install.sh --dir /opt/panel

    # Development with SQLite
    bash install.sh --dir ~/panel-dev

QUICK PERSIST/VERIFY (safe one-liner)
    # If you've previously generated a DB password into /tmp/panel_db_vars,
    # persist it into the install directory and show masked verification:
    bash -lc 'INSTALL_DIR=/workspaces/panel/.panel_full_install; ENV="$INSTALL_DIR/.env"; SECRETS="$INSTALL_DIR/.install_secrets"; TMP_VARS=/tmp/panel_db_vars; if [[ -f "$TMP_VARS" ]]; then DB_PASS=$(sed -n "s/^DB_PASS=\(.*\)$/\1/p" "$TMP_VARS"); else DB_PASS=""; fi; DB_USER=$(grep -E "^PANEL_DB_USER=" "$ENV" 2>/dev/null || true); DB_USER="${DB_USER#PANEL_DB_USER=}"; DB_USER="${DB_USER:-panel_user}"; if [[ -z "$DB_PASS" ]]; then echo "ERROR: DB_PASS empty â€” check /tmp/panel_db_vars"; exit 2; fi; mkdir -p "$(dirname "$SECRETS")"; umask 077; tmp=$(mktemp -p "$(dirname "$SECRETS")" ".install_secrets.XXXXXX") || tmp="$SECRETS.tmp"; printf "# Panel generated secrets\nPANEL_DB_USER=%s\nPANEL_DB_PASS=%s\n" "$DB_USER" "$DB_PASS" > "$tmp"; chmod 600 "$tmp"; mv -f "$tmp" "$SECRETS"; sed -i.bak "/^PANEL_DB_PASS=/d" "$ENV" 2>/dev/null || true; printf "PANEL_DB_PASS=%s\n" "$DB_PASS" >> "$ENV"; echo "Wrote $SECRETS (mode $(stat -c '%a' \"$SECRETS\" 2>/dev/null || echo 600))"; echo "Masked PANEL_DB_PASS: ${DB_PASS:0:4}...${DB_PASS: -4}"; ls -l "$SECRETS" "$ENV"; echo '--- .install_secrets ---'; sed -n '1,200p' "$SECRETS"; echo '--- .env tail ---'; tail -n 50 "$ENV" || true'

AVAILABLE INSTALLER FUNCTIONS:
    Core Functions:
      â€¢ log()                  - Print informational messages
      â€¢ success()              - Print success messages
      â€¢ error()                - Print error messages and exit
      â€¢ warn()                 - Print warning messages
      â€¢ show_help()            - Display help message

    System Detection:
      â€¢ detect_pkg_manager()   - Detect OS package manager
      â€¢ detect_sudo()          - Detect if sudo is needed

    Validation Functions:
      â€¢ check_python_version() - Verify Python 3.8+ is available
      â€¢ check_disk_space()     - Ensure 500MB+ free space
      â€¢ check_network()        - Test internet connectivity
      â€¢ validate_port()        - Check if port is available
      â€¢ verify_installation()  - Verify existing installation

    Installation Functions:
      â€¢ install_dependencies() - Install system packages
      â€¢ setup_postgresql()     - Configure PostgreSQL database
      â€¢ install_nginx()        - Install and configure Nginx
      â€¢ install_panel()        - Main installation orchestrator
      â€¢ setup_python_env()     - Create venv and install deps
      â€¢ configure_database()   - Generate database config
      â€¢ create_admin_user()    - Create initial admin account
      â€¢ setup_services()       - Configure systemd services
      â€¢ setup_logrotate()      - Configure log rotation
      â€¢ health_check()         - Test panel startup

    Utility Functions:
      â€¢ generate_secret()      - Generate secure random key
      â€¢ prompt_user()          - Interactive user prompts
      â€¢ backup_installation()  - Backup existing installation

USER ROLES:
    The panel supports 5 permission levels (lowest to highest):
      â€¢ user            - Basic forum posting and thread creation
      â€¢ moderator       - Forum moderation, pin/lock threads, edit/delete posts
      â€¢ server_mod      - Monitor server status, view logs
      â€¢ server_admin    - Start/stop servers, modify configurations
      â€¢ system_admin    - Full system access, user management, all features

    The installer creates a system_admin user by default.

UNINSTALLATION:
    For complete uninstallation including system dependencies, use:
    curl -fsSL https://raw.githubusercontent.com/phillgates2/panel/main/uninstall.sh | bash

    See 'bash uninstall.sh --help' for uninstallation options.

EOF
    exit 0
}

# ============================================================================
# Helper Functions
# ============================================================================

log() { echo -e "${GREEN}[INFO]${NC} $*"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; exit 1; }

# Cleanup on failure
cleanup_on_error() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        warn "Installation failed with exit code $exit_code"
        if [[ -n "$BACKUP_DIR" ]] && [[ -d "$BACKUP_DIR" ]]; then
            log "Backup available at: $BACKUP_DIR"
        fi
    fi
}

trap cleanup_on_error EXIT

# Validation functions
check_python_version() {
    log "Checking Python version..."
    if ! command -v python3 &>/dev/null; then
        error "Python 3 is not installed"
    fi

    local python_version=$(python3 -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")')
    local required_version="3.8"

    # Compare versions using sort -V (version sort)
    local lowest=$(printf '%s\n%s' "$python_version" "$required_version" | sort -V | head -n1)
    if [[ "$lowest" != "$required_version" ]]; then
        error "Python $required_version or higher required (found: $python_version)"
    fi

    log "Python version: $python_version âœ“"
}

check_disk_space() {
    log "Checking disk space..."
    local install_parent=$(dirname "$INSTALL_DIR")
    local available_mb=$(df -m "$install_parent" 2>/dev/null | awk 'NR==2 {print $4}')
    local required_mb=500

    if [[ -n "$available_mb" ]] && [[ "$available_mb" -lt "$required_mb" ]]; then
        warn "Low disk space: ${available_mb}MB available, ${required_mb}MB recommended"
        if [[ "$NON_INTERACTIVE" == "true" ]]; then
            warn "Non-interactive mode: proceeding despite low disk space"
        else
            if ! prompt_confirm "Continue anyway?" "n"; then
                error "Installation cancelled due to insufficient disk space"
            fi
        fi
    else
        log "Disk space: ${available_mb}MB available âœ“"
    fi
}

check_network() {
    log "Checking network connectivity..."
    if command -v curl &>/dev/null; then
        if ! curl -s --connect-timeout 5 https://github.com >/dev/null 2>&1; then
            warn "Cannot reach GitHub. Check your internet connection."
            if [[ "$NON_INTERACTIVE" == "true" ]]; then
                error "Network unreachable in non-interactive mode. Aborting."
            else
                if ! prompt_confirm "Continue anyway?" "n"; then
                    error "Installation cancelled due to network issues"
                fi
            fi
        else
            log "Network connectivity âœ“"
        fi
    fi
}

detect_system() {
    log "Detecting system..."

    # Detect package manager
    if command -v apt-get &>/dev/null; then
        PKG_MANAGER="apt-get"
    elif command -v dnf &>/dev/null; then
        PKG_MANAGER="dnf"
    elif command -v yum &>/dev/null; then
        PKG_MANAGER="yum"
    elif command -v apk &>/dev/null; then
        PKG_MANAGER="apk"
    elif command -v pacman &>/dev/null; then
        PKG_MANAGER="pacman"
    elif command -v brew &>/dev/null; then
        PKG_MANAGER="brew"
    else
        error "Unsupported package manager. Please install manually."
    fi

    # Setup sudo if needed
    if [[ $EUID -ne 0 ]]; then
        if command -v sudo &>/dev/null; then
            SUDO="sudo"
            log "Running as user with sudo"
        else
            warn "Running as non-root without sudo - some operations may fail"
        fi
    else
        log "Running as root"
    fi

    log "System: $PKG_MANAGER"
}

prompt_input() {
    local prompt="$1"
    local default="$2"
    local is_secret="${3:-false}"
    local response

    if [[ "$NON_INTERACTIVE" == "true" ]]; then
        echo "$default"
        return
    fi

    if [[ "$is_secret" == "true" ]]; then
        echo -e "${YELLOW}$prompt${NC} (default: [hidden]): " >&2
        if [[ -t 0 ]]; then
            read -s response
        else
            read -s response < /dev/tty
        fi
        echo >&2
    else
        echo -e "${YELLOW}$prompt${NC} (default: $default): " >&2
        if [[ -t 0 ]]; then
            read response
        else
            read response < /dev/tty
        fi
    fi

    echo "${response:-$default}"
}

prompt_confirm() {
    local prompt="$1"
    local default="${2:-n}"

    if [[ "$NON_INTERACTIVE" == "true" ]]; then
        [[ "$default" == "y" ]] && return 0 || return 1
    fi

    local response
    echo -e "${YELLOW}$prompt [y/n]${NC} (default: $default): " >&2

    # Read from /dev/tty to handle piped input
    if [[ -t 0 ]]; then
        read response
    else
        read response < /dev/tty
    fi

    response="${response:-$default}"

    [[ "$response" =~ ^[Yy] ]]
}

# Persist secrets atomically and securely
persist_db_secrets() {
    # Arguments: [install_dir] [secrets_file] [db_user] [db_pass] [admin_email] [admin_pass]
    local dir="${1:-$INSTALL_DIR}"
    local secrets_file="${2:-$dir/.install_secrets}"
    local db_user="${3:-$DB_USER}"
    local db_pass="${4:-$DB_PASS}"
    local admin_email="${5:-$ADMIN_EMAIL}"
    local admin_pass="${6:-$ADMIN_PASSWORD}"

    mkdir -p "$dir" || true
    # Generate a panel secret key if not present
    local panel_secret_key_val
    if [[ -n "${PANEL_SECRET_KEY_VAL:-}" ]]; then
        panel_secret_key_val="$PANEL_SECRET_KEY_VAL"
    else
        panel_secret_key_val=$(python3 -c 'import secrets; print(secrets.token_hex(32))')
    fi

    # Use restrictive umask and write to a temp file then move into place
    umask 077
    local tmp
    tmp=$(mktemp -p "$dir" ".install_secrets.XXXXXX") || tmp="$dir/.install_secrets.tmp"
    {
        printf "# Panel generated secrets - keep this file secure\n"
        printf "PANEL_SECRET_KEY=%s\n" "$panel_secret_key_val"
        printf "PANEL_DB_USER=%s\n" "$db_user"
        printf "PANEL_DB_PASS=%s\n" "$db_pass"
        printf "PANEL_ADMIN_EMAIL=%s\n" "$admin_email"
        printf "PANEL_ADMIN_PASS=%s\n" "$admin_pass"
    } > "$tmp"
    chmod 600 "$tmp" || true
    mv -f "$tmp" "$secrets_file"

    # Update .env if present under install dir
    local envf="$dir/.env"
    if [[ -f "$envf" ]]; then
        # remove previous PANEL_DB_PASS lines safely
        sed -i.bak '/^PANEL_DB_PASS=/d' "$envf" 2>/dev/null || true
        printf "PANEL_DB_PASS=%s\n" "$db_pass" >> "$envf"
    fi

    log "Wrote secrets to: $secrets_file (mode $(stat -c '%a' "$secrets_file" 2>/dev/null || echo '600'))"
}

# ============================================================================
# System Dependencies
# ============================================================================

check_installed() {
    local pkg="$1"
    case "$PKG_MANAGER" in
        apt-get)
            dpkg -l "$pkg" 2>/dev/null | grep -q '^ii' && return 0
            ;;
        dnf|yum)
            rpm -q "$pkg" &>/dev/null && return 0
            ;;
        apk)
            apk info -e "$pkg" &>/dev/null && return 0
            ;;
        pacman)
            pacman -Q "$pkg" &>/dev/null && return 0
            ;;
        brew)
            brew list "$pkg" &>/dev/null && return 0
            ;;
    esac
    return 1
}

install_system_deps() {
    if [[ "$SKIP_DEPS" == "true" ]]; then
        log "Skipping system dependencies (PANEL_SKIP_DEPS=true)"
        return 0
    fi

    log "Checking and installing system dependencies..."

    local to_install=()
    local deps_map=()

    case "$PKG_MANAGER" in
        apt-get)
            deps_map=("python3" "python3-pip" "python3-venv" "git" "curl" "wget" "redis-server" "nginx" "build-essential" "libssl-dev" "libffi-dev" "libpq-dev" "postgresql-client")
            for dep in "${deps_map[@]}"; do
                if ! check_installed "$dep"; then
                    to_install+=("$dep")
                fi
            done
            if [[ ${#to_install[@]} -gt 0 ]]; then
                log "Installing: ${to_install[*]}"
                $SUDO apt-get update -qq
                $SUDO apt-get install -y -qq "${to_install[@]}"
            else
                log "All apt dependencies already installed âœ“"
            fi
            ;;
        dnf|yum)
            deps_map=("python3" "python3-pip" "python3-devel" "git" "curl" "wget" "redis" "nginx" "gcc" "openssl-devel" "libffi-devel" "postgresql-devel")
            for dep in "${deps_map[@]}"; do
                if ! check_installed "$dep"; then
                    to_install+=("$dep")
                fi
            done
            if [[ ${#to_install[@]} -gt 0 ]]; then
                log "Installing: ${to_install[*]}"
                $SUDO $PKG_MANAGER install -y -q "${to_install[@]}"
            else
                log "All dnf/yum dependencies already installed âœ“"
            fi
            ;;
        apk)
            deps_map=("python3" "py3-pip" "git" "curl" "wget" "redis" "nginx" "gcc" "musl-dev" "linux-headers" "libffi-dev" "openssl-dev" "postgresql-dev")
            for dep in "${deps_map[@]}"; do
                if ! check_installed "$dep"; then
                    to_install+=("$dep")
                fi
            done
            if [[ ${#to_install[@]} -gt 0 ]]; then
                log "Installing: ${to_install[*]}"
                $SUDO apk add --no-cache "${to_install[@]}"
            else
                log "All apk dependencies already installed âœ“"
            fi
            ;;
        pacman)
            deps_map=("python" "python-pip" "git" "curl" "wget" "redis" "nginx" "base-devel" "postgresql-libs")
            for dep in "${deps_map[@]}"; do
                if ! check_installed "$dep"; then
                    to_install+=("$dep")
                fi
            done
            if [[ ${#to_install[@]} -gt 0 ]]; then
                log "Installing: ${to_install[*]}"
                $SUDO pacman -S --noconfirm --needed "${to_install[@]}"
            else
                log "All pacman dependencies already installed âœ“"
            fi
            ;;
        brew)
            deps_map=("python3" "git" "curl" "wget" "redis" "nginx" "postgresql")
            for dep in "${deps_map[@]}"; do
                if ! check_installed "$dep"; then
                    to_install+=("$dep")
                fi
            done
            if [[ ${#to_install[@]} -gt 0 ]]; then
                log "Installing: ${to_install[*]}"
                brew install "${to_install[@]}"
            else
                log "All brew dependencies already installed âœ“"
            fi
            ;;
    esac

    # Configure and start Redis
    log "Configuring Redis server..."
    if command -v systemctl &>/dev/null; then
        # Enable Redis to start on boot
        $SUDO systemctl enable redis 2>/dev/null || $SUDO systemctl enable redis-server 2>/dev/null || true
        # Start Redis now
        $SUDO systemctl start redis 2>/dev/null || $SUDO systemctl start redis-server 2>/dev/null || true
        # Check if Redis is running
        if systemctl is-active --quiet redis 2>/dev/null || systemctl is-active --quiet redis-server 2>/dev/null; then
            log "Redis server started âœ“"
        else
            warn "Redis server not started via systemctl, attempting alternative methods..."
            if command -v redis-server &>/dev/null; then
                redis-server --daemonize yes 2>/dev/null || true
            fi
        fi
    elif command -v service &>/dev/null; then
        $SUDO service redis start 2>/dev/null || $SUDO service redis-server start 2>/dev/null || true
    elif command -v redis-server &>/dev/null; then
        redis-server --daemonize yes 2>/dev/null || true
    fi

    # Verify Redis is accessible
    if command -v redis-cli &>/dev/null; then
        if redis-cli ping &>/dev/null; then
            log "Redis server is running and accessible âœ“"
        else
            warn "Redis installed but not responding. You may need to start it manually."
        fi
    fi

    # Configure Nginx
    log "Configuring Nginx server..."
    if command -v nginx &>/dev/null; then
        # On Debian/Ubuntu, remove default site that conflicts with port 80
        if [[ "$PKG_MANAGER" == "apt-get" ]]; then
            if [[ -L "/etc/nginx/sites-enabled/default" ]]; then
                log "Removing default nginx site..."
                $SUDO rm -f /etc/nginx/sites-enabled/default
            fi
        fi

        # Test nginx configuration
        if $SUDO nginx -t 2>&1 | grep -q "successful"; then
            log "Nginx configuration valid âœ“"
        else
            warn "Nginx configuration test failed, attempting to fix..."
            # Create basic nginx config if missing
            if [[ ! -f "/etc/nginx/nginx.conf" ]]; then
                warn "Missing nginx.conf - reinstalling nginx"
                case "$PKG_MANAGER" in
                    apt-get)
                        $SUDO apt-get install --reinstall -y nginx
                        ;;
                esac
            fi
        fi

        # Enable and start Nginx
        if command -v systemctl &>/dev/null; then
            $SUDO systemctl enable nginx 2>/dev/null || true
            # Stop nginx first to clear any errors
            $SUDO systemctl stop nginx 2>/dev/null || true
            sleep 1
            # Start nginx
            if $SUDO systemctl start nginx 2>&1; then
                sleep 1
                if systemctl is-active --quiet nginx; then
                    log "Nginx server started âœ“"
                else
                    warn "Nginx failed to start. Checking status..."
                    $SUDO systemctl status nginx --no-pager -l 2>&1 | head -20 || true
                    warn "You may need to configure nginx manually"
                fi
            else
                warn "Failed to start nginx service"
            fi
        elif command -v service &>/dev/null; then
            $SUDO service nginx stop 2>/dev/null || true
            sleep 1
            if $SUDO service nginx start 2>&1; then
                log "Nginx server started âœ“"
            else
                warn "Failed to start nginx via service command"
            fi
        fi

        # Verify nginx is listening
        sleep 2
        if command -v netstat &>/dev/null; then
            if netstat -tlnp 2>/dev/null | grep -q ":80.*nginx"; then
                log "Nginx is listening on port 80 âœ“"
            else
                warn "Nginx may not be listening on port 80"
            fi
        fi
    fi

    log "System dependencies installed and configured"
}

# ============================================================================
# PostgreSQL Setup
# ============================================================================

setup_postgresql() {
    if [[ "$DB_TYPE" != "postgresql" ]]; then
        log "Using SQLite - skipping PostgreSQL setup"
        return 0
    fi

    if [[ "$SKIP_POSTGRESQL" == "true" ]]; then
        log "Skipping PostgreSQL setup (PANEL_SKIP_POSTGRESQL=true)"
        return 0
    fi

    log "Setting up PostgreSQL..."

    # Install PostgreSQL
    case "$PKG_MANAGER" in
        apt-get)
            $SUDO apt-get install -y -qq postgresql postgresql-contrib
            ;;
        dnf|yum)
            $SUDO $PKG_MANAGER install -y -q postgresql postgresql-server
            $SUDO postgresql-setup --initdb 2>/dev/null || true
            ;;
        apk)
            $SUDO apk add --no-cache postgresql postgresql-contrib
            $SUDO mkdir -p /run/postgresql
            $SUDO chown postgres:postgres /run/postgresql
            ;;
        pacman)
            $SUDO pacman -S --noconfirm --needed postgresql
            $SUDO -u postgres initdb -D /var/lib/postgres/data 2>/dev/null || true
            ;;
        brew)
            brew install postgresql
            ;;
    esac

    # Start PostgreSQL
    if command -v systemctl &>/dev/null; then
        $SUDO systemctl enable postgresql 2>/dev/null || true
        $SUDO systemctl start postgresql 2>/dev/null || true
    fi

    # Create database and user
    log "Creating PostgreSQL database..."

    if [[ -z "$DB_PASS" ]]; then
        DB_PASS=$(python3 - <<'PY'
import secrets
print(secrets.token_urlsafe(16))
PY
)
        log "Generated database password: [redacted]"
    fi

    $SUDO -u postgres psql -c "CREATE USER $DB_USER WITH PASSWORD '$DB_PASS';" 2>/dev/null || true
    $SUDO -u postgres psql -c "CREATE DATABASE $DB_NAME OWNER $DB_USER;" 2>/dev/null || true
    $SUDO -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;" 2>/dev/null || true

    log "PostgreSQL setup complete"
}

# ============================================================================
# Service Management Functions
# ============================================================================

ensure_redis_running() {
    log "Checking Redis server..."

    if pgrep -x redis-server > /dev/null 2>&1; then
        log "Redis is already running âœ“"
        return 0
    fi

    log "Starting Redis server..."
    if command -v systemctl &>/dev/null; then
        $SUDO systemctl start redis 2>/dev/null || $SUDO systemctl start redis-server 2>/dev/null || true
    elif command -v service &>/dev/null; then
        $SUDO service redis start 2>/dev/null || $SUDO service redis-server start 2>/dev/null || true
    elif command -v redis-server &>/dev/null; then
        redis-server --daemonize yes 2>/dev/null || true
    fi

    sleep 2

    if pgrep -x redis-server > /dev/null 2>&1; then
        log "Redis server started âœ“"
        # Test connectivity
        if command -v redis-cli &>/dev/null && redis-cli ping &>/dev/null; then
            log "Redis responding to ping âœ“"
        fi
    else
        warn "Failed to start Redis. Panel background jobs may not work."
        return 1
    fi
}

ensure_postgresql_running() {
    log "Checking PostgreSQL server..."

    if pgrep -x postgres > /dev/null 2>&1 || pgrep -x postmaster > /dev/null 2>&1; then
        log "PostgreSQL is already running âœ“"
        return 0
    fi

    log "Starting PostgreSQL server..."
    if command -v systemctl &>/dev/null; then
        $SUDO systemctl start postgresql 2>/dev/null || true
    elif command -v service &>/dev/null; then
        $SUDO service postgresql start 2>/dev/null || true
    elif command -v pg_ctl &>/dev/null; then
        # Try to start with pg_ctl (for user installations)
        $SUDO -u postgres pg_ctl start -D /var/lib/postgres/data 2>/dev/null || true
    fi

    sleep 3

    if pgrep -x postgres > /dev/null 2>&1 || pgrep -x postmaster > /dev/null 2>&1; then
        log "PostgreSQL server started âœ“"
    else
        warn "Failed to start PostgreSQL automatically."
        return 1
    fi
}

ensure_nginx_running() {
    if [[ "$SETUP_NGINX" != "true" ]]; then
        return 0
    fi

    log "Checking Nginx server..."

    if systemctl is-active --quiet nginx 2>/dev/null || pgrep nginx > /dev/null 2>&1; then
        log "Nginx is already running âœ“"
        return 0
    fi

    log "Starting Nginx server..."
    if command -v systemctl &>/dev/null; then
        # Test config first
        if $SUDO nginx -t 2>&1 | grep -q "successful"; then
            $SUDO systemctl start nginx 2>/dev/null || true
        else
            warn "Nginx configuration test failed"
            return 1
        fi
    elif command -v service &>/dev/null; then
        $SUDO service nginx start 2>/dev/null || true
    fi

    sleep 2

    if systemctl is-active --quiet nginx 2>/dev/null || pgrep nginx > /dev/null 2>&1; then
        log "Nginx server started âœ“"
    else
        warn "Failed to start Nginx"
        return 1
    fi
}

setup_systemd_services() {
    if [[ "$SETUP_SYSTEMD" != "true" ]]; then
        log "Skipping systemd service setup (development mode)"
        return 0
    fi

    if ! command -v systemctl &>/dev/null; then
        warn "systemd not available on this system"
        return 1
    fi

    log "Setting up systemd services..."

    # Setup Gunicorn service
    if [[ -f "$INSTALL_DIR/deploy/panel-gunicorn.service" ]]; then
        log "Configuring panel-gunicorn service..."
        sed -e "s|/home/YOUR_USER/panel|$INSTALL_DIR|g" \
            -e "s|YOUR_USER|$USER|g" \
            -e "s|127.0.0.1:8080|127.0.0.1:$APP_PORT|g" \
            "$INSTALL_DIR/deploy/panel-gunicorn.service" | \
        $SUDO tee /etc/systemd/system/panel-gunicorn.service > /dev/null

        $SUDO systemctl daemon-reload
        $SUDO systemctl enable panel-gunicorn 2>/dev/null || true
        log "Gunicorn service configured âœ“"
    fi

    # Setup RQ Worker service
    if [[ -f "$INSTALL_DIR/deploy/rq-worker.service" ]]; then
        log "Configuring rq-worker service..."
        sed -e "s|/home/YOUR_USER/panel|$INSTALL_DIR|g" \
            -e "s|YOUR_USER|$USER|g" \
            "$INSTALL_DIR/deploy/rq-worker.service" | \
        $SUDO tee /etc/systemd/system/rq-worker.service > /dev/null

        $SUDO systemctl daemon-reload
        $SUDO systemctl enable rq-worker 2>/dev/null || true
        log "RQ worker service configured âœ“"
    fi

    log "Systemd services configured successfully"
}

start_systemd_services() {
    if [[ "$SETUP_SYSTEMD" != "true" ]]; then
        return 0
    fi

    log "Starting systemd services..."

    if [[ -f /etc/systemd/system/panel-gunicorn.service ]]; then
        $SUDO systemctl start panel-gunicorn 2>/dev/null || warn "Failed to start panel-gunicorn"
        sleep 2
        if systemctl is-active --quiet panel-gunicorn; then
            log "Gunicorn service started âœ“"
        fi
    fi

    if [[ -f /etc/systemd/system/rq-worker.service ]]; then
        $SUDO systemctl start rq-worker 2>/dev/null || warn "Failed to start rq-worker"
        sleep 2
        if systemctl is-active --quiet rq-worker; then
            log "RQ worker service started âœ“"
        fi
    fi
}

setup_nginx_config() {
    if [[ "$SETUP_NGINX" != "true" ]]; then
        return 0
    fi

    log "Configuring Nginx reverse proxy..."

    # Check for non-SSL template first
    local template_file=""
    if [[ -f "$INSTALL_DIR/deploy/nginx_panel_nossl.conf" ]]; then
        template_file="$INSTALL_DIR/deploy/nginx_panel_nossl.conf"
    elif [[ -f "$INSTALL_DIR/deploy/nginx_game_chrisvanek.conf" ]]; then
        template_file="$INSTALL_DIR/deploy/nginx_game_chrisvanek.conf"
    else
        warn "Nginx template not found"
        return 1
    fi

    # Create nginx config
    local nginx_conf="$INSTALL_DIR/deploy/nginx_panel.conf"

    # Use non-SSL config or strip SSL from existing config
    if [[ "$template_file" == *"nossl"* ]]; then
        sed -e "s/YOUR_DOMAIN_HERE/$DOMAIN/g" \
            -e "s|/home/YOUR_USER/panel|$INSTALL_DIR|g" \
            -e "s|YOUR_USER|$USER|g" \
            -e "s|127.0.0.1:8080|127.0.0.1:$APP_PORT|g" \
            "$template_file" > "$nginx_conf"
    else
        # Strip SSL config from template
        sed -e "s/YOUR_DOMAIN_HERE/$DOMAIN/g" \
            -e "s|/home/YOUR_USER/panel|$INSTALL_DIR|g" \
            -e "s|YOUR_USER|$USER|g" \
            -e "s|127.0.0.1:8080|127.0.0.1:$APP_PORT|g" \
            "$template_file" | \
            sed '/listen 443/,/^}/d' | \
            sed '/return 301 https/d' > "$nginx_conf"
    fi

    log "Nginx configuration created: $nginx_conf"

    # Install config
    case "$PKG_MANAGER" in
        apt-get)
            if [[ -d "/etc/nginx/sites-available" ]]; then
                $SUDO cp "$nginx_conf" /etc/nginx/sites-available/panel
                $SUDO ln -sf /etc/nginx/sites-available/panel /etc/nginx/sites-enabled/panel 2>/dev/null || true
                log "Nginx config installed to sites-available"
            fi
            ;;
        *)
            if [[ -d "/etc/nginx/conf.d" ]]; then
                $SUDO cp "$nginx_conf" /etc/nginx/conf.d/panel.conf
                log "Nginx config installed to conf.d"
            fi
            ;;
    esac

    # Test nginx config
    log "Testing nginx configuration..."
    if $SUDO nginx -t 2>&1 | grep -q "successful"; then
        log "Nginx configuration valid âœ“"
        if systemctl is-active --quiet nginx 2>/dev/null || pgrep nginx > /dev/null 2>&1; then
            $SUDO systemctl reload nginx 2>/dev/null || $SUDO service nginx reload 2>/dev/null || true
            log "Nginx reloaded with new configuration"
        else
            log "Nginx not running - start it manually with: sudo systemctl start nginx"
        fi
    else
        warn "Nginx configuration test failed - config may have issues"
        echo
        echo "  To debug:"
        echo "    sudo nginx -t"
        echo "    cat $nginx_conf"
        echo
        echo "  The Panel will still work on port $APP_PORT without nginx"
        return 0  # Don't fail installation
    fi
}

setup_ssl_certificates() {
    if [[ "$SETUP_SSL" != "true" ]]; then
        return 0
    fi

    if [[ "$DOMAIN" == "localhost" ]] || [[ "$DOMAIN" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        warn "SSL setup requires a valid domain name (not localhost or IP)"
        return 1
    fi

    log "Setting up SSL with Let's Encrypt..."

    # Install certbot
    if ! command -v certbot &>/dev/null; then
        log "Installing certbot..."
        case "$PKG_MANAGER" in
            apt-get)
                $SUDO apt-get install -y -qq certbot python3-certbot-nginx
                ;;
            dnf|yum)
                $SUDO $PKG_MANAGER install -y -q certbot python3-certbot-nginx
                ;;
            apk)
                $SUDO apk add --no-cache certbot certbot-nginx
                ;;
            pacman)
                $SUDO pacman -S --noconfirm --needed certbot certbot-nginx
                ;;
            brew)
                brew install certbot
                ;;
        esac
    fi

    # Run certbot
    if command -v certbot &>/dev/null; then
        log "Obtaining SSL certificate for $DOMAIN..."
        if $SUDO certbot --nginx -d "$DOMAIN" --non-interactive --agree-tos --email "$ADMIN_EMAIL" 2>&1 | tee /tmp/certbot.log; then
            log "SSL certificate obtained successfully âœ“"
        else
            warn "SSL certificate setup failed. See /tmp/certbot.log"
            return 1
        fi
    fi
}

perform_health_check() {
    log "Performing health check..."
    local health_ok=false
    local retries=0
    local max_retries=10
    local check_url="http://localhost:$APP_PORT"

    # Determine which URL to check
    if [[ "$SETUP_NGINX" == "true" ]]; then
        check_url="http://localhost"
    fi

    # Check if gunicorn service is running
    if command -v systemctl &>/dev/null && [[ "$SETUP_SYSTEMD" == "true" ]]; then
        if ! systemctl is-active --quiet panel-gunicorn 2>/dev/null; then
            warn "Gunicorn service is not active"
            warn "Service status:"
            $SUDO systemctl status panel-gunicorn --no-pager -l 2>&1 | head -20
        fi
    fi

    while [[ $retries -lt $max_retries ]]; do
        if command -v curl &>/dev/null; then
            # Try /health endpoint
            if curl -f -s -m 5 "$check_url/health" >/dev/null 2>&1; then
                health_ok=true
                log "Health check passed âœ“ ($check_url/health)"
                break
            fi

            # Try root endpoint
            if curl -f -s -m 5 "$check_url/" >/dev/null 2>&1; then
                health_ok=true
                log "Health check passed âœ“ ($check_url/)"
                break
            fi
        fi

        retries=$((retries + 1))
        if [[ $retries -lt $max_retries ]]; then
            log "Waiting for Panel to respond... ($retries/$max_retries)"
            sleep 3
        fi
    done

    if [[ "$health_ok" == "true" ]]; then
        log "Panel is responding correctly âœ“"
        return 0
    else
        warn "Panel health check failed - service may not be running correctly"
        warn "Check logs: $INSTALL_DIR/logs/"
        if [[ -f "$INSTALL_DIR/logs/panel.log" ]]; then
            warn "Recent errors from panel.log:"
            tail -20 "$INSTALL_DIR/logs/panel.log" 2>/dev/null | grep -i "error\|exception\|traceback" || echo "(no recent errors found)"
        fi
        # Don't fail installation, just warn
        warn "Installation completed with warnings - manual verification recommended"
        return 0
    fi
}



# ============================================================================
# Panel Installation
# ============================================================================

# Enforce required environment variables in non-interactive mode
require_non_interactive_vars() {
    if [[ "$NON_INTERACTIVE" != "true" ]]; then
        return 0
    fi
    log "Running in non-interactive mode: ensuring required variables (auto-generating missing ones)"

    # Enforce PostgreSQL-only behavior
    DB_TYPE="postgresql"

    # DB user
    if [[ -z "$DB_USER" ]]; then
        DB_USER="panel_user"
        log "Auto-set DB user: $DB_USER"
    fi

    # DB password
    if [[ -z "$DB_PASS" ]]; then
        DB_PASS=$(python3 - <<'PY'
import secrets
print(secrets.token_urlsafe(16))
PY
)
        if [[ "$REDACT_SECRETS" == "true" ]]; then
            log "Auto-generated DB password (redacted)"
        else
            log "Auto-generated DB password (save this): $DB_PASS"
        fi
    fi

    # Admin email
    if [[ -z "$ADMIN_EMAIL" ]]; then
        ADMIN_EMAIL="admin@localhost"
        log "Auto-set admin email: $ADMIN_EMAIL"
    fi

    # Admin password
    if [[ -z "$ADMIN_PASSWORD" ]]; then
        ADMIN_PASSWORD=$(python3 - <<'PY'
import secrets
print(secrets.token_urlsafe(12))
PY
)
        if [[ "$REDACT_SECRETS" == "true" ]]; then
            log "Auto-generated admin password (redacted)"
        else
            log "Auto-generated admin password (save this): $ADMIN_PASSWORD"
        fi
    fi

    # Install dir must be set (has default), ensure parent exists or can be created
    local parent_dir
    parent_dir=$(dirname "$INSTALL_DIR")
    if [[ ! -d "$parent_dir" ]]; then
        if ! mkdir -p "$parent_dir" 2>/dev/null; then
            error "Cannot create installation parent directory: $parent_dir"
        fi
    fi
}

# Load a configuration file (key=value lines or JSON). For .env or shell-style files,
# this will `source` the file in a controlled manner; for JSON it will parse via Python.
load_config_file() {
    local cfg="$1"
    if [[ -z "$cfg" ]]; then
        return 0
    fi
    if [[ ! -f "$cfg" ]]; then
        error "Config file not found: $cfg"
    fi
    log "Loading configuration from: $cfg"

    case "$cfg" in
        *.json)
            # Parse JSON into KEY=VALUE lines and export them
            while IFS= read -r line; do
                [[ -z "$line" ]] && continue
                export "$line"
            done < <(python3 - "$cfg" <<'PY'
import json,sys
data=json.load(open(sys.argv[1]))
for k,v in data.items():
    if isinstance(v,(list,dict)):
        continue
    print(f"{k}={v}")
PY
)
            ;;
        *.yml|*.yaml)
            # YAML support: try to import yaml; if missing, optionally install PyYAML
            if ! python3 -c 'import yaml' >/dev/null 2>&1; then
                if [[ "$NO_PIP_INSTALL" == "true" ]]; then
                    error "PyYAML is required to parse YAML config files. You passed --no-pip-install; please install PyYAML manually: python3 -m pip install pyyaml"
                fi

                # Verify TLS/OpenSSL availability before pip operations
                if ! python3 - <<'PY' 2>/dev/null
import ssl
ver = getattr(ssl, 'OPENSSL_VERSION', None)
if not ver:
    raise SystemExit(2)
print(ver)
PY
                then
                    error "TLS/OpenSSL not available for secure pip installs. Install PyYAML manually or enable TLS support."
                fi

                log "PyYAML not found; attempting to install via pip..."
                if python3 -m pip install --user pyyaml --quiet --disable-pip-version-check; then
                    log "PyYAML installed successfully (user)"
                else
                    warn "Automatic PyYAML install failed; trying system-wide install"
                    if python3 -m pip install pyyaml --quiet --disable-pip-version-check; then
                        log "PyYAML installed successfully (system-wide)"
                    else
                        error "PyYAML is required to parse YAML config files and could not be installed automatically. Install it manually: python3 -m pip install pyyaml"
                    fi
                fi
            fi
            # Read parsed key=val lines from python and export
            while IFS= read -r line; do
                [[ -z "$line" ]] && continue
                export "$line"
            done < <(python3 - "$cfg" <<'PY'
import yaml,sys
data=yaml.safe_load(open(sys.argv[1]))
for k,v in (data or {}).items():
    if isinstance(v,(list,dict)):
        continue
    print(f"{k}={v}")
PY
)
            ;;
        *)
            # shell-style key=val file; export variables
            # Use a subshell to avoid executing unexpected commands
            set -o allexport
            # shellcheck disable=SC1090
            source "$cfg"
            set +o allexport
            ;;
    esac
}

# Start panel services (worker + web) and perform basic health checks
start_panel_services() {
    log "Starting Panel services (background)..."
    cd "$INSTALL_DIR" || { warn "Cannot cd to $INSTALL_DIR"; return 1; }

    # Activate venv if present
    if [[ -f "$INSTALL_DIR/venv/bin/activate" ]]; then
        # shellcheck disable=SC1091
        source "$INSTALL_DIR/venv/bin/activate"
    fi

    mkdir -p "$INSTALL_DIR/logs" "$INSTALL_DIR/instance/logs" "$INSTALL_DIR/instance/audit_logs" "$INSTALL_DIR/instance/backups"

    # Start worker
    if [[ -f "$INSTALL_DIR/run_worker.py" ]]; then
        nohup python3 run_worker.py > "$INSTALL_DIR/logs/worker.log" 2>&1 &
        WORKER_PID=$!
        log "Worker started (PID: $WORKER_PID)"
    else
        warn "run_worker.py not found; skipping worker start"
    fi

    # Start web server
    if [[ -f "$INSTALL_DIR/app.py" ]]; then
        nohup python3 app.py > "$INSTALL_DIR/logs/panel.log" 2>&1 &
        SERVER_PID=$!
        log "Web server started (PID: $SERVER_PID)"
    else
        warn "app.py not found; cannot start web server"
    fi

    # Basic health check
    sleep 3
    if command -v curl &>/dev/null; then
        if curl -f -s -m 5 "http://localhost:$APP_PORT/health" >/dev/null 2>&1 || curl -f -s -m 5 "http://localhost:$APP_PORT/" >/dev/null 2>&1; then
            log "Panel responded on http://localhost:$APP_PORT"
        else
            warn "Panel did not respond immediately on port $APP_PORT. Check logs: $INSTALL_DIR/logs/panel.log"
        fi
    else
        warn "curl not available; cannot perform HTTP health check"
    fi
}

install_panel() {
    log "Installing Panel to $INSTALL_DIR..."

    # Check if critical ports are available
    log "Checking port availability..."
    if command -v netstat &>/dev/null; then
        if netstat -tlnp 2>/dev/null | grep -q ":$APP_PORT "; then
            warn "Port $APP_PORT is already in use"
            if ! prompt_confirm "Continue anyway?" "y"; then
                error "Installation cancelled"
            fi
        fi
        if [[ "$DB_TYPE" == "postgresql" ]] && netstat -tlnp 2>/dev/null | grep -q ":$DB_PORT "; then
            warn "PostgreSQL port $DB_PORT is already in use (this may be normal if PostgreSQL is already running)"
        fi
    fi

    # Clone repository
    if [[ -d "$INSTALL_DIR" ]]; then
        warn "Directory exists: $INSTALL_DIR"
        if [[ "$NON_INTERACTIVE" == "true" ]]; then
            # In non-interactive mode, automatically backup existing installation
            BACKUP_DIR="${INSTALL_DIR}.backup.$(date +%s)"
            log "Non-interactive mode: backing up existing installation to: $BACKUP_DIR"
            mv "$INSTALL_DIR" "$BACKUP_DIR"
            log "Backup created. To restore: mv $BACKUP_DIR $INSTALL_DIR"
        else
            if ! prompt_confirm "Remove existing installation?" "n"; then
                error "Installation cancelled"
            fi
            # Backup existing installation
            BACKUP_DIR="${INSTALL_DIR}.backup.$(date +%s)"
            log "Creating backup: $BACKUP_DIR"
            mv "$INSTALL_DIR" "$BACKUP_DIR"
            log "Backup created. To restore: mv $BACKUP_DIR $INSTALL_DIR"
        fi
    fi

    git clone --branch "$BRANCH" "$REPO_URL" "$INSTALL_DIR"
    cd "$INSTALL_DIR"

    # Create virtual environment
    log "Creating Python virtual environment..."
    python3 -m venv venv
    source venv/bin/activate

    # Install Python dependencies
    log "Installing Python dependencies..."
    pip install --upgrade pip wheel setuptools

    # Try installing requirements, fallback to binary-only for psycopg2 on Python 3.13+
    if ! pip install -r requirements.txt 2>&1 | tee /tmp/pip_install.log; then
        warn "Initial pip install failed, trying with binary-only psycopg2..."
        # Install everything except psycopg2 first
        grep -v "psycopg2" requirements.txt > /tmp/requirements_no_psycopg2.txt
        pip install -r /tmp/requirements_no_psycopg2.txt
        # Then install psycopg2-binary from prebuilt wheel only
        pip install psycopg2-binary --only-binary :all: || {
            warn "Could not install prebuilt psycopg2-binary wheel"
            warn "Attempting to build from source (may fail on Python 3.13)..."
            pip install psycopg2-binary
        }
        rm -f /tmp/requirements_no_psycopg2.txt
    fi
    rm -f /tmp/pip_install.log

    # Create .env file
    log "Creating configuration..."

# Generate PANEL_SECRET_KEY (use Python if openssl not available)
PANEL_SECRET_KEY_VAL=$(python3 - <<'PY'
import secrets
print(secrets.token_hex(32))
PY
)
    cat > .env << EOF
# Panel Configuration - Generated $(date)
PANEL_SECRET_KEY=${PANEL_SECRET_KEY_VAL}
FLASK_APP=app.py
FLASK_ENV=production
FLASK_DEBUG=$DEBUG_MODE

# Database (PostgreSQL only)
PANEL_USE_SQLITE=0
PANEL_DB_HOST=$DB_HOST
PANEL_DB_PORT=$DB_PORT
PANEL_DB_NAME=$DB_NAME
PANEL_DB_USER=$DB_USER
PANEL_DB_PASS=$DB_PASS

# Server
FLASK_HOST=$APP_HOST
FLASK_PORT=$APP_PORT

# Redis
PANEL_REDIS_URL=redis://127.0.0.1:6379/0

# Admin (for reference - actual user created in database)
# Admin Email: $ADMIN_EMAIL
# Admin Role: system_admin
PANEL_ADMIN_EMAILS=$ADMIN_EMAIL

# Logging
LOG_LEVEL=INFO
LOG_DIR=instance/logs
AUDIT_LOG_ENABLED=True
AUDIT_LOG_DIR=instance/audit_logs


EOF

    # Initialize database
    log "Initializing database..."
    python3 << 'PYEOF' || warn "Database initialization failed"
from app import app, db
with app.app_context():
    db.create_all()
    print("Database tables created successfully")
PYEOF

    # Run CMS/Forum migration
    log "Running CMS and Forum migrations..."
    if [[ -f "migrate_cms_forum.py" ]]; then
        python3 migrate_cms_forum.py --non-interactive || warn "CMS/Forum migration had warnings (may be already applied)"
    else
        warn "migrate_cms_forum.py not found, skipping CMS/Forum migrations"
    fi

    # After CMS/Forum migration, automate Ptero Eggs setup
    log "Automating Ptero Eggs setup..."
    if [[ -f "ptero_eggs_updater.py" ]]; then
        python3 ptero_eggs_updater.py --auto || warn "Ptero Eggs automation had warnings (may be already applied)"
    else
        warn "ptero_eggs_updater.py not found, skipping Ptero Eggs automation"
    fi

    # Create admin user
    log "Creating admin user..."
    python3 << PYEOF || warn "Admin user creation failed"
import os
from datetime import datetime, date
from app import app, db, User
from werkzeug.security import generate_password_hash

try:
    with app.app_context():
        # Check if admin user already exists
        admin = User.query.filter_by(email='${ADMIN_EMAIL}').first()
        if not admin:
            # User model requires: first_name, last_name, email, dob, password_hash
            admin = User(
                first_name='Admin',
                last_name='User',
                email='${ADMIN_EMAIL}',
                dob=date(2000, 1, 1),  # Default DOB
                password_hash=generate_password_hash('${ADMIN_PASSWORD}'),
                role='system_admin',
                is_active=True
            )
            db.session.add(admin)
            db.session.commit()
            print(f"Admin user '${ADMIN_EMAIL}' created successfully with role 'system_admin'")
        else:
            print(f"Admin user '${ADMIN_EMAIL}' already exists")
except Exception as e:
    print(f"Could not create admin user: {e}")
    import traceback
    traceback.print_exc()
PYEOF

    # Configure nginx
    log "Configuring nginx..."
    # Use non-SSL config by default (SSL can be added later with certbot)
    if [[ -f "deploy/nginx_panel_nossl.conf" ]]; then
        sed -e "s/YOUR_DOMAIN_HERE/$DOMAIN/g" \
            -e "s|/home/YOUR_USER/panel|$INSTALL_DIR|g" \
            -e "s|YOUR_USER|$USER|g" \
            deploy/nginx_panel_nossl.conf > deploy/nginx_panel.conf
        log "Nginx configuration created: deploy/nginx_panel.conf (HTTP only)"
    elif [[ -f "deploy/nginx_game_chrisvanek.conf" ]]; then
        # Fallback to old config but create HTTP-only version
        sed -e "s/YOUR_DOMAIN_HERE/$DOMAIN/g" \
            -e "s|/home/YOUR_USER/panel|$INSTALL_DIR|g" \
            -e "s|YOUR_USER|$USER|g" \
            deploy/nginx_game_chrisvanek.conf | \
            sed '/listen 443/,/^}/d' | \
            sed '/return 301 https/d' > deploy/nginx_panel.conf
        log "Nginx configuration created: deploy/nginx_panel.conf (HTTP only)"
    fi

    # Configure systemd service files
    log "Configuring systemd services..."
    if [[ -f "deploy/panel-gunicorn.service" ]]; then
        sed -e "s|/home/YOUR_USER/panel|$INSTALL_DIR|g" \
            -e "s|YOUR_USER|$USER|g" \
            deploy/panel-gunicorn.service > deploy/panel-gunicorn.service.configured
        log "Gunicorn service configured: deploy/panel-gunicorn.service.configured"
    fi

    if [[ -f "deploy/rq-worker.service" ]]; then
        sed -e "s|/home/YOUR_USER/panel|$INSTALL_DIR|g" \
            -e "s|YOUR_USER|$USER|g" \
            deploy/rq-worker.service > deploy/rq-worker.service.configured
        log "RQ worker service configured: deploy/rq-worker.service.configured"
    fi

    # Setup log rotation
    log "Configuring log rotation..."
    if [[ -f "deploy/panel-logrotate.conf" ]]; then
        if [[ -d "/etc/logrotate.d" ]] && [[ -n "$SUDO" ]]; then
            $SUDO cp deploy/panel-logrotate.conf /etc/logrotate.d/panel 2>/dev/null || \
                log "Log rotation setup skipped (requires sudo)"
        fi
    fi

    # Validate configuration
    log "Validating configuration..."
    if [[ ! -f ".env" ]]; then
        error "Configuration file (.env) was not created"
    fi

    # Save installation info
    cat > "$INSTALL_DIR/.install_info" << INFOEOF
# Panel Installation Info - $(date)
INSTALL_DATE=$(date -Iseconds)
INSTALL_DIR=$INSTALL_DIR
DB_TYPE=$DB_TYPE
DOMAIN=$DOMAIN
APP_PORT=$APP_PORT
ADMIN_EMAIL=$ADMIN_EMAIL
BRANCH=$BRANCH
INFOEOF

    # Save credentials securely (only readable by owner)
    if [[ "$DB_TYPE" == "postgresql" ]] && [[ -n "$DB_PASS" ]]; then
        cat > "$INSTALL_DIR/.db_credentials" << CREDEOF
# Database Credentials - KEEP SECURE
DB_HOST=$DB_HOST
DB_PORT=$DB_PORT
DB_NAME=$DB_NAME
DB_USER=$DB_USER
DB_PASS=$DB_PASS
CREDEOF
        chmod 600 "$INSTALL_DIR/.db_credentials"
        log "Database credentials saved to: $INSTALL_DIR/.db_credentials (chmod 600)"
    fi

    # Optionally write generated secrets to an installer artifact
    if [[ "$SAVE_SECRETS" == "true" ]]; then
        SECRETS_FILE="$INSTALL_DIR/.install_secrets"
        # Extract PANEL_SECRET_KEY from .env if present
        if grep -q '^PANEL_SECRET_KEY=' .env 2>/dev/null; then
            PANEL_SECRET_KEY_VAL=$(grep '^PANEL_SECRET_KEY=' .env | cut -d'=' -f2-)
        else
            PANEL_SECRET_KEY_VAL=""
        fi

        cat > "$SECRETS_FILE" << SEOF
# Panel generated secrets - keep this file secure
PANEL_SECRET_KEY=${PANEL_SECRET_KEY_VAL}
PANEL_DB_USER=${DB_USER}
PANEL_DB_PASS=${DB_PASS}
PANEL_ADMIN_EMAIL=${ADMIN_EMAIL}
PANEL_ADMIN_PASS=${ADMIN_PASSWORD}
SEOF
        chmod 600 "$SECRETS_FILE"
        log "Installer secrets written to: $SECRETS_FILE (chmod 600)"
    fi

    log "Panel installation complete"
}

# ============================================================================
# Installation Verification
# ============================================================================

verify_installation() {
    log "Verifying installation..."
    local errors=0

    # Check .env file
    if [[ ! -f "$INSTALL_DIR/.env" ]]; then
        warn "Missing .env file"
        ((errors++))
    fi

    # Check venv
    if [[ ! -d "$INSTALL_DIR/venv" ]]; then
        warn "Missing virtual environment"
        ((errors++))
    fi

    # Check app.py
    if [[ ! -f "$INSTALL_DIR/app.py" ]]; then
        warn "Missing app.py"
        ((errors++))
    fi

    # Check Python packages
    if [[ -d "$INSTALL_DIR/venv" ]]; then
        cd "$INSTALL_DIR"
        if ! venv/bin/python -c "import flask" 2>/dev/null; then
            warn "Flask not properly installed"
            ((errors++))
        fi
    fi

    # Check database connection
    cd "$INSTALL_DIR"
    if ! venv/bin/python << 'PYEOF' 2>/dev/null
from dotenv import load_dotenv
load_dotenv()
from app import app, db
with app.app_context():
    db.engine.connect()
    print("Database connection successful")
PYEOF
    then
        warn "Database connection test failed"
        ((errors++))
    fi

    if [[ $errors -eq 0 ]]; then
        log "Installation verification passed âœ“"
        return 0
    else
        warn "Installation verification found $errors issue(s)"
        return 1
    fi
}

# ============================================================================
# Interactive Setup
# ============================================================================

interactive_setup() {
    echo
    echo -e "${BOLD}${MAGENTA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BOLD}${MAGENTA}â•‘       Interactive Configuration           â•‘${NC}"
    echo -e "${BOLD}${MAGENTA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo

    log "Starting interactive configuration..."

    # Installation Mode Selection
    echo
    echo -e "${BOLD}${YELLOW}Installation Mode${NC}"
    echo -e "  ${GREEN}1)${NC} Development (local testing, debug mode enabled)"
    echo -e "  ${GREEN}2)${NC} Production (systemd services, nginx, ssl-ready)"
    echo -e "  ${GREEN}3)${NC} Custom (choose specific components)"
    echo
    INSTALL_MODE=$(prompt_input "Select installation mode [1-3]" "1")

    case "$INSTALL_MODE" in
        1)
            log "Development mode selected"
            DEBUG_MODE="true"
            SETUP_SYSTEMD="false"
            SETUP_NGINX="false"
            SETUP_SSL="false"
            APP_PORT="8080"
            ;;
        2)
            log "Production mode selected"
            DEBUG_MODE="false"
            SETUP_SYSTEMD="true"
            SETUP_NGINX="true"
            SETUP_SSL="prompt"
            APP_PORT="8000"
            ;;
        3)
            log "Custom mode selected"
            SETUP_SYSTEMD=$(prompt_confirm "Setup systemd services?" "y") && SETUP_SYSTEMD="true" || SETUP_SYSTEMD="false"
            SETUP_NGINX=$(prompt_confirm "Setup nginx reverse proxy?" "y") && SETUP_NGINX="true" || SETUP_NGINX="false"
            SETUP_SSL=$(prompt_confirm "Setup SSL/Let's Encrypt?" "n") && SETUP_SSL="true" || SETUP_SSL="false"
            DEBUG_MODE=$(prompt_confirm "Enable debug mode?" "n") && DEBUG_MODE="true" || DEBUG_MODE="false"
            ;;
        *)
            warn "Invalid selection, using development mode"
            DEBUG_MODE="true"
            SETUP_SYSTEMD="false"
            SETUP_NGINX="false"
            SETUP_SSL="false"
            ;;
    esac

    # Database Configuration
    echo
    echo -e "${BOLD}${YELLOW}Database Configuration (PostgreSQL)${NC}"
    echo -e "${YELLOW}Configure PostgreSQL connection settings${NC}"
    DB_TYPE="postgresql"
    DB_HOST=$(prompt_input "PostgreSQL host" "$DB_HOST")
    DB_PORT=$(prompt_input "PostgreSQL port" "$DB_PORT")
    DB_NAME=$(prompt_input "Database name" "$DB_NAME")
    DB_USER=$(prompt_input "Database user" "$DB_USER")
    DB_PASS=$(prompt_input "Database password (leave empty to generate)" "" "true")

    if [[ -z "$DB_PASS" ]]; then
        DB_PASS=$(python3 -c 'import secrets; print(secrets.token_urlsafe(16))')
        log "Generated secure database password"
    fi

    # Installation Directory
    echo
    echo -e "${BOLD}${YELLOW}Installation Settings${NC}"
    INSTALL_DIR=$(prompt_input "Installation directory" "$INSTALL_DIR")
    log "Installation directory: $INSTALL_DIR"

    # Network Configuration
    echo
    echo -e "${BOLD}${YELLOW}Network Configuration${NC}"
    echo -e "${YELLOW}Enter the domain or IP where Panel will be accessible${NC}"
    echo -e "${YELLOW}Examples: panel.example.com, 192.168.1.100, localhost${NC}"
    DOMAIN=$(prompt_input "Domain/IP address" "localhost")

    if [[ "$SETUP_NGINX" == "false" ]]; then
        APP_PORT=$(prompt_input "Application port" "$APP_PORT")
    else
        log "Using port 8000 (nginx will proxy from 80/443)"
        APP_PORT="8000"
    fi

    # Admin Account
    echo
    echo -e "${BOLD}${YELLOW}Admin Account Setup${NC}"
    echo -e "${YELLOW}Create a system administrator account${NC}"
    ADMIN_EMAIL=$(prompt_input "Admin email address" "$ADMIN_EMAIL")
    ADMIN_PASSWORD=$(prompt_input "Admin password (leave empty to generate)" "" "true")

    if [[ -z "$ADMIN_PASSWORD" ]]; then
        ADMIN_PASSWORD=$(python3 -c 'import secrets; print(secrets.token_urlsafe(12))')
        log "Generated secure admin password"
    fi

    # Optional Features
    echo
    echo -e "${BOLD}${YELLOW}Optional Features${NC}"
    SAVE_SECRETS=$(prompt_confirm "Save generated credentials to .install_secrets?" "y") && SAVE_SECRETS="true" || SAVE_SECRETS="false"

    # Summary
    echo
    echo -e "${BOLD}${MAGENTA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BOLD}${MAGENTA}â•‘         Panel Installer v3.0              â•‘${NC}"
    echo -e "${BOLD}${MAGENTA}â•‘         PostgreSQL Edition                â•‘${NC}"
    echo -e "${BOLD}${MAGENTA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "  Mode: ${GREEN}$([[ "$DEBUG_MODE" == "true" ]] && echo "Development" || echo "Production")${NC}"
    echo -e "  Install to: ${GREEN}$INSTALL_DIR${NC}"
    echo -e "  Database: ${GREEN}PostgreSQL ($DB_HOST:$DB_PORT/$DB_NAME)${NC}"
    echo -e "  Domain: ${GREEN}$DOMAIN${NC}"
    echo -e "  Port: ${GREEN}$APP_PORT${NC}"
    echo -e "  Admin: ${GREEN}$ADMIN_EMAIL${NC}"
    echo -e "  Systemd: ${GREEN}$SETUP_SYSTEMD${NC}"
    echo -e "  Nginx: ${GREEN}$SETUP_NGINX${NC}"
    echo -e "  SSL: ${GREEN}$SETUP_SSL${NC}"
    echo
    echo -e "${BOLD}${YELLOW}Database Configuration (PostgreSQL)${NC}"
    echo -e "${YELLOW}Configure PostgreSQL connection settings${NC}"
    echo -e "  Host: ${GREEN}$DB_HOST${NC}"
    echo -e "  Port: ${GREEN}$DB_PORT${NC}"
    echo -e "  Name: ${GREEN}$DB_NAME${NC}"
    echo -e "  User: ${GREEN}$DB_USER${NC}"
    echo -e "  Pass: ${GREEN}$DB_PASS${NC}"
    echo
    echo -e "${BOLD}${YELLOW}Admin Account Setup${NC}"
    echo -e "${YELLOW}Create a system administrator account${NC}"
    echo -e "  Email: ${GREEN}$ADMIN_EMAIL${NC}"
    echo -e "  Password: ${GREEN}$ADMIN_PASSWORD${NC}"
    echo
    echo -e "${BOLD}${MAGENTA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BOLD}${MAGENTA}â•‘         Panel Installer v3.0              â•‘${NC}"
    echo -e "${BOLD}${MAGENTA}â•‘         PostgreSQL Edition                â•‘${NC}"
    echo -e "${BOLD}${MAGENTA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo

    if ! prompt_confirm "Proceed with installation?" "y"; then
        error "Installation cancelled by user"
    fi

    log "Interactive configuration complete"
}

# ============================================================================
# Main Installation Flow
# ============================================================================

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                ;;
            -d|--dir)
                INSTALL_DIR="$2"
                shift 2
                ;;
            -b|--branch)
                BRANCH="$2"
                shift 2
                ;;
            --sqlite)
                warn "SQLite is not supported by this installer; forcing PostgreSQL"
                DB_TYPE="postgresql"
                shift
                ;;
            --postgresql)
                DB_TYPE="postgresql"
                shift
                ;;
            --non-interactive)
                NON_INTERACTIVE="true"
                shift
                ;;
            -y|--yes|--force)
                FORCE="true"
                NON_INTERACTIVE="true"
                shift
                ;;
            --no-pip-install)
                NO_PIP_INSTALL="true"
                shift
                ;;
            --redact-secrets)
                REDACT_SECRETS="true"
                shift
                ;;
            --config)
                CONFIG_FILE="$2"
                shift 2
                ;;
            --skip-deps)
                SKIP_DEPS="true"
                shift
                ;;
            --skip-postgresql)
                SKIP_POSTGRESQL="true"
                shift
                ;;
                    --save-secrets)
                        SAVE_SECRETS="true"
                        shift
                        ;;
            --verify-only)
                # Just verify existing installation
                if [[ -d "$INSTALL_DIR" ]]; then
                    cd "$INSTALL_DIR"
                    verify_installation
                    exit $?
                else
                    error "No installation found at $INSTALL_DIR"
                fi
                ;;
            --update)
                # Update existing installation
                if [[ -d "$INSTALL_DIR" ]]; then
                    log "Updating existing installation at $INSTALL_DIR"
                    cd "$INSTALL_DIR"

                    # Backup current version
                    BACKUP_DIR="${INSTALL_DIR}.backup.$(date +%s)"
                    log "Creating backup: $BACKUP_DIR"
                    cp -r "$INSTALL_DIR" "$BACKUP_DIR"

                    # Pull latest changes
                    git pull origin main

                    # Update dependencies
                    source venv/bin/activate
                    pip install --upgrade -r requirements.txt

                    # Run migrations if needed
                    if command -v flask &>/dev/null; then
                        flask db upgrade 2>/dev/null || true
                    fi

                    # Run CMS/Forum migration
                    log "Running CMS and Forum migrations..."
                    if [[ -f "migrate_cms_forum.py" ]]; then
                        python3 migrate_cms_forum.py --non-interactive || warn "CMS/Forum migration had warnings (may be already applied)"
                    fi

                    log "Update complete"
                    exit 0
                else
                    error "No installation found at $INSTALL_DIR"
                fi
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
    done
}

main() {
    parse_args "$@"
    # If a config file was provided, load it now and map PANEL_* variables
    if [[ -n "$CONFIG_FILE" ]]; then
        load_config_file "$CONFIG_FILE"
        # Map common PANEL_ vars to local vars used by the installer
        DB_TYPE="${PANEL_DB_TYPE:-$DB_TYPE}"
        DB_HOST="${PANEL_DB_HOST:-$DB_HOST}"
        DB_PORT="${PANEL_DB_PORT:-$DB_PORT}"
        DB_NAME="${PANEL_DB_NAME:-$DB_NAME}"
        DB_USER="${PANEL_DB_USER:-$DB_USER}"
        DB_PASS="${PANEL_DB_PASS:-$DB_PASS}"
        ADMIN_EMAIL="${PANEL_ADMIN_EMAIL:-$ADMIN_EMAIL}"
        ADMIN_PASSWORD="${PANEL_ADMIN_PASS:-$ADMIN_PASSWORD}"
        INSTALL_DIR="${PANEL_INSTALL_DIR:-$INSTALL_DIR}"
        BRANCH="${PANEL_BRANCH:-$BRANCH}"
        NON_INTERACTIVE="${PANEL_NON_INTERACTIVE:-$NON_INTERACTIVE}"
    fi

    # After loading config and validating, support config-only test mode:
    require_non_interactive_vars
    if [[ "$INSTALLER_CONFIG_ONLY" == "true" ]]; then
        log "INSTALLER_CONFIG_ONLY=true - exiting after config validation"
        # Ensure install dir exists for writing secrets if requested
        if [[ "$SAVE_SECRETS" == "true" ]]; then
            # Use helper to persist secrets atomically and securely
            persist_db_secrets "$INSTALL_DIR" "$INSTALL_DIR/.install_secrets" "$DB_USER" "$DB_PASS" "$ADMIN_EMAIL" "$ADMIN_PASSWORD"
        fi
        exit 0
    fi

    echo
    echo -e "${BOLD}${MAGENTA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BOLD}${MAGENTA}â•‘         Panel Installer v3.0              â•‘${NC}"
    echo -e "${BOLD}${MAGENTA}â•‘         PostgreSQL Edition                â•‘${NC}"
    echo -e "${BOLD}${MAGENTA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo

    detect_system

    log "NON_INTERACTIVE=$NON_INTERACTIVE"

    if [[ "$NON_INTERACTIVE" != "true" ]]; then
        log "Running interactive setup..."
        interactive_setup
    else
        log "Skipping interactive setup (non-interactive mode)"
    fi

    # Validate required settings when running non-interactively
    require_non_interactive_vars

    # Pre-installation checks
    echo
    log "Running pre-installation checks..."
    check_python_version
    check_disk_space
    check_network
    echo

    # Install and configure system dependencies BEFORE panel installation
    log "Installing system dependencies (nginx, redis, build tools, etc.)..."
    install_system_deps

    # Verify critical services are running before proceeding
    log "Verifying critical services..."

    # Check Redis
    if ! pgrep -x redis-server > /dev/null 2>&1; then
        warn "Redis is not running. Attempting to start..."
        if command -v systemctl &>/dev/null; then
            $SUDO systemctl start redis 2>/dev/null || $SUDO systemctl start redis-server 2>/dev/null || true
        fi
        sleep 2
        if ! pgrep -x redis-server > /dev/null 2>&1; then
            error "Redis failed to start. Please start it manually: sudo systemctl start redis"
        fi
    fi
    log "Redis is running âœ“"

    # Check Nginx - REQUIRED for production
    # Nginx should already be installed by install_system_deps
    if ! command -v nginx &>/dev/null; then
        # Try to find nginx binary in common locations
        if [[ -f /usr/sbin/nginx ]]; then
            export PATH="/usr/sbin:$PATH"
        elif [[ -f /usr/local/sbin/nginx ]]; then
            export PATH="/usr/local/sbin:$PATH"
        elif [[ -f /usr/local/bin/nginx ]]; then
            export PATH="/usr/local/bin:$PATH"
        else
            error "Nginx was not installed by the package manager.
Check if SKIP_DEPS=true is set: echo \$SKIP_DEPS
Try installing manually: sudo $PKG_MANAGER install nginx"
        fi
    fi

    # Configure nginx (remove default site on Debian/Ubuntu)
    if [[ "$PKG_MANAGER" == "apt-get" ]] && [[ -L "/etc/nginx/sites-enabled/default" ]]; then
        log "Removing default nginx site..."
        $SUDO rm -f /etc/nginx/sites-enabled/default
    fi

    # Now verify nginx is running
    if ! systemctl is-active --quiet nginx 2>/dev/null && ! pgrep nginx > /dev/null 2>&1; then
        warn "Nginx is not running. Attempting to start..."
        if command -v systemctl &>/dev/null; then
            $SUDO systemctl start nginx 2>/dev/null || true
        elif command -v service &>/dev/null; then
            $SUDO service nginx start 2>/dev/null || true
        fi
        sleep 2
        # Verify again
        if ! systemctl is-active --quiet nginx 2>/dev/null && ! pgrep nginx > /dev/null 2>&1; then
            error "Nginx failed to start. Please check nginx configuration and start it manually: sudo systemctl start nginx"
        fi
    fi
    log "Nginx is running âœ“"

    echo

    setup_postgresql
    ensure_postgresql_running
    ensure_redis_running

    install_panel

    # Setup production services if requested
    if [[ "$SETUP_SYSTEMD" == "true" ]]; then
        setup_systemd_services
    fi

    if [[ "$SETUP_NGINX" == "true" ]]; then
        setup_nginx_config
    fi

    if [[ "$SETUP_SSL" == "true" ]]; then
        setup_ssl_certificates
    fi

    verify_installation

    # Auto-start services
    if [[ "$AUTO_START" == "true" ]]; then
        log "Auto-starting Panel services..."

        if [[ "$SETUP_SYSTEMD" == "true" ]]; then
            start_systemd_services
        else
            # Start in development mode
            start_panel_services
        fi

        # Health check
        sleep 5
        perform_health_check
    fi

    echo
    echo -e "${BOLD}${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BOLD}${GREEN}â•‘   Installation Complete!                  â•‘${NC}"
    echo -e "${BOLD}${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo
    echo -e "${GREEN}Installation Directory:${NC} $INSTALL_DIR"
    echo -e "${GREEN}Database Type:${NC} $DB_TYPE"
    echo -e "${GREEN}Domain:${NC} $DOMAIN"
    echo -e "${GREEN}Admin Email:${NC} $ADMIN_EMAIL"
    echo -e "${GREEN}Admin Role:${NC} system_admin"
    if [[ -f "$INSTALL_DIR/.db_credentials" ]]; then
        echo -e "${YELLOW}Database credentials saved:${NC} $INSTALL_DIR/.db_credentials"
    fi
    if [[ -n "$BACKUP_DIR" ]] && [[ -d "$BACKUP_DIR" ]]; then
        echo -e "${YELLOW}Previous installation backed up:${NC} $BACKUP_DIR"
    fi
    echo

    # Ask if user wants to start the panel now
    if [[ "$NON_INTERACTIVE" != "true" ]]; then
        echo -e "${YELLOW}Would you like to start the Panel now? (y/n)${NC}" >&2
        read -r -p "> " START_NOW < /dev/tty || START_NOW="n"

        if [[ "$START_NOW" =~ ^[Yy] ]]; then
            echo
            echo -e "${GREEN}Starting Panel services...${NC}"

            # Check if Redis is running, start if needed
            if ! pgrep -x redis-server > /dev/null 2>&1; then
                echo -e "${YELLOW}Starting Redis...${NC}"
                if command -v systemctl &>/dev/null; then
                    $SUDO systemctl start redis 2>/dev/null || $SUDO systemctl start redis-server 2>/dev/null || true
                elif command -v service &>/dev/null; then
                    $SUDO service redis start 2>/dev/null || $SUDO service redis-server start 2>/dev/null || true
                else
                    redis-server --daemonize yes 2>/dev/null || true
                fi
                sleep 1
            fi

            # Verify Redis is running
            if ! pgrep -x redis-server > /dev/null 2>&1; then
                warn "Redis is not running. Background worker may fail."
                echo -e "${YELLOW}To start Redis manually:${NC}"
                echo "  sudo systemctl start redis"
                echo "  # or"
                echo "  redis-server --daemonize yes"
            else
                echo -e "${GREEN}âœ“ Redis is running${NC}"
            fi

            # Start worker in background
            cd "$INSTALL_DIR" || exit 1
            source venv/bin/activate

            # Create logs and instance directories if they don't exist
            mkdir -p logs instance/logs instance/audit_logs instance/backups

            # Start worker
            echo -e "${YELLOW}Starting background worker...${NC}"
            nohup python3 run_worker.py > logs/worker.log 2>&1 &
            WORKER_PID=$!
            echo -e "${GREEN}Worker started with PID: $WORKER_PID${NC}"

            # Start web server
            echo -e "${YELLOW}Starting web server...${NC}"
            nohup python3 app.py > logs/panel.log 2>&1 &
            SERVER_PID=$!
            echo -e "${GREEN}Web server started with PID: $SERVER_PID${NC}"

            # Wait for services to initialize (Flask debug mode takes longer)
            echo -e "${YELLOW}Waiting for services to initialize...${NC}"
            sleep 5

            # Check if Panel is actually running (check for python process, not just PID)
            # Flask debug mode spawns child processes, so we check for the actual app.py process
            PANEL_RUNNING=false
            RETRY_COUNT=0
            MAX_RETRIES=10

            while [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; do
                if pgrep -f "python3 app.py" > /dev/null 2>&1 || pgrep -f "python.*app.py" > /dev/null 2>&1; then
                    PANEL_RUNNING=true
                    break
                fi
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; then
                    echo -e "${YELLOW}Checking process status... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)${NC}"
                    sleep 5
                fi
            done

            if [[ "$PANEL_RUNNING" == "true" ]]; then
                # Get actual PIDs
                ACTUAL_SERVER_PIDS=$(pgrep -f "python.*app.py" | tr '\n' ' ')
                ACTUAL_WORKER_PIDS=$(pgrep -f "python.*run_worker.py" | tr '\n' ' ')

                # Health check
                log "Performing health check..."
                sleep 3
                HEALTH_OK=false

                # Try multiple endpoints
                if command -v curl &>/dev/null; then
                    # Try health endpoint first
                    if curl -f -s -m 5 http://localhost:$APP_PORT/health >/dev/null 2>&1; then
                        HEALTH_OK=true
                        echo -e "${GREEN}âœ“ Panel health check passed${NC}"
                    # Try root endpoint as fallback
                    elif curl -f -s -m 5 http://localhost:$APP_PORT/ >/dev/null 2>&1; then
                        HEALTH_OK=true
                        echo -e "${GREEN}âœ“ Panel responding (health endpoint not available)${NC}"
                    else
                        warn "Panel health check failed (but process is running)"
                        warn "This is normal for first startup - panel may still be initializing"
                        warn "Wait 15-30 seconds then check: http://$DOMAIN:$APP_PORT"
                    fi
                fi

                echo
                echo -e "${BOLD}${GREEN}âœ“ Panel is now running!${NC}"
                echo
                echo -e "${GREEN}Access Panel:${NC}"
                echo -e "  URL: ${BOLD}http://$DOMAIN:$APP_PORT${NC}"
                echo -e "  Email: ${BOLD}$ADMIN_EMAIL${NC}"
                echo -e "  Password: ${BOLD}[set during installation]${NC}"
                echo -e "  Role: ${BOLD}system_admin${NC}"
                echo
                echo -e "${YELLOW}Running Processes:${NC}"
                echo "  Panel PIDs: $ACTUAL_SERVER_PIDS"
                echo "  Worker PIDs: $ACTUAL_WORKER_PIDS"
                echo
                echo -e "${YELLOW}To view logs:${NC}"
                echo "  Panel: tail -f $INSTALL_DIR/logs/panel.log"
                echo "  Worker: tail -f $INSTALL_DIR/logs/worker.log"
                echo
                echo -e "${YELLOW}To stop the Panel:${NC}"
                echo "  pkill -f 'python.*app.py'"
                echo "  pkill -f 'python.*run_worker.py'"
                echo
                echo -e "${YELLOW}Troubleshooting:${NC}"
                echo "  Run health check: $INSTALL_DIR/panel-health-check.sh"
                echo "  Check if port is listening: netstat -tuln | grep $APP_PORT"
                echo "  Test connection: curl http://localhost:$APP_PORT/"
            else
                echo
                echo -e "${YELLOW}âš  Panel startup taking longer than expected${NC}"
                echo
                if [[ -f "$INSTALL_DIR/logs/panel.log" ]]; then
                    echo -e "${YELLOW}Last 30 lines from panel.log:${NC}"
                    tail -30 "$INSTALL_DIR/logs/panel.log"
                    echo
                    echo -e "${GREEN}If you see initialization messages above, the Panel is starting.${NC}"
                    echo -e "${GREEN}Wait 15-30 seconds and try:${NC}"
                    echo -e "  ${BOLD}curl http://localhost:$APP_PORT/${NC}"
                    echo -e "  ${BOLD}$INSTALL_DIR/panel-health-check.sh${NC}"
                    echo
                    echo -e "${YELLOW}If connection fails after 30 seconds:${NC}"
                    echo "  1. Check errors: tail -100 $INSTALL_DIR/logs/panel.log | grep ERROR"
                    echo "  2. Check process: ps aux | grep 'python.*app.py'"
                    echo "  3. Check port: netstat -tuln | grep $APP_PORT"
                    echo "  4. Try manual start:"
                    echo "       cd $INSTALL_DIR && source venv/bin/activate && python3 app.py"
                else
                    echo "  Log file not created: $INSTALL_DIR/logs/panel.log"
                    echo "  Try starting manually:"
                    echo "    cd $INSTALL_DIR"
                    echo "    source venv/bin/activate"
                    echo "    python3 app.py"
                fi
            fi
        else
            echo
            echo -e "${YELLOW}To start the Panel manually:${NC}"
            echo "  cd $INSTALL_DIR"
            echo "  source venv/bin/activate"
            echo "  nohup python3 run_worker.py > logs/worker.log 2>&1 &"
            echo "  nohup python3 app.py > logs/panel.log 2>&1 &"
            echo
            echo -e "${GREEN}Access Panel (once started):${NC}"
            echo -e "  URL: ${BOLD}http://$DOMAIN:$APP_PORT${NC}"
            echo -e "  Email: ${BOLD}$ADMIN_EMAIL${NC}"
            echo
        fi
    else
        # Non-interactive mode - show manual start instructions
        # In non-interactive mode, attempt to start services automatically
        log "Non-interactive mode: attempting to start Panel services automatically"
        start_panel_services || warn "Automatic service start failed; see logs in $INSTALL_DIR/logs"
        echo
        echo -e "${GREEN}Access Panel (if started):${NC}"
        echo -e "  URL: ${BOLD}http://$DOMAIN:$APP_PORT${NC}"
        echo -e "  Email: ${BOLD}$ADMIN_EMAIL${NC}"
        echo
    fi

    echo -e "${GREEN}Database Admin UI:${NC}"
    echo "  http://$DOMAIN:$APP_PORT/admin/database"
    echo
    echo -e "${GREEN}Community Features:${NC}"
    echo "  Forum: http://$DOMAIN:$APP_PORT/forum"
    echo "  Blog: http://$DOMAIN:$APP_PORT/cms/blog"
    echo "  Blog Admin: http://$DOMAIN:$APP_PORT/cms/admin/blog"
    echo
    echo -e "${BOLD}${YELLOW}ðŸ“‹ Next Steps:${NC}"
    echo
    echo -e "${YELLOW}1. Start the Panel:${NC}"
    echo "   cd $INSTALL_DIR"
    echo "   source venv/bin/activate"
    echo "   python3 app.py"
    echo
    echo -e "${YELLOW}2. Access the Panel:${NC}"
    echo "   http://$DOMAIN:$APP_PORT"
    echo "   Login with: $ADMIN_EMAIL"
    echo
    echo -e "${YELLOW}3. For Production (Optional):${NC}"
    echo "   - Setup systemd services (see instructions below)"
    echo "   - Configure nginx reverse proxy"
    echo "   - Setup SSL with Let's Encrypt"
    echo "   - Configure firewall rules"
    echo
    echo -e "${YELLOW}Production Setup:${NC}"
    echo "  For production, set up systemd services and nginx:"
    echo
    echo "  # Setup Gunicorn service"
    if [[ -f "$INSTALL_DIR/deploy/panel-gunicorn.service.configured" ]]; then
        echo "  sudo cp $INSTALL_DIR/deploy/panel-gunicorn.service.configured /etc/systemd/system/panel-gunicorn.service"
    else
        echo "  sudo cp $INSTALL_DIR/deploy/panel-gunicorn.service /etc/systemd/system/"
        echo "  # Edit /etc/systemd/system/panel-gunicorn.service to set correct paths"
    fi
    echo "  sudo systemctl daemon-reload"
    echo "  sudo systemctl enable panel-gunicorn"
    echo "  sudo systemctl start panel-gunicorn"
    echo
    echo "  # Setup RQ Worker service"
    if [[ -f "$INSTALL_DIR/deploy/rq-worker.service.configured" ]]; then
        echo "  sudo cp $INSTALL_DIR/deploy/rq-worker.service.configured /etc/systemd/system/rq-worker.service"
    else
        echo "  sudo cp $INSTALL_DIR/deploy/rq-worker.service /etc/systemd/system/"
        echo "  # Edit /etc/systemd/system/rq-worker.service to set correct paths"
    fi
    echo "  sudo systemctl daemon-reload"
    echo "  sudo systemctl enable rq-worker"
    echo "  sudo systemctl start rq-worker"
    echo
    echo "  # Setup Nginx reverse proxy (configured for: $DOMAIN)"
    if [[ -f "$INSTALL_DIR/deploy/nginx_panel.conf" ]]; then
        case "$PKG_MANAGER" in
            apt-get)
                echo "  sudo cp $INSTALL_DIR/deploy/nginx_panel.conf /etc/nginx/sites-available/panel"
                echo "  sudo ln -s /etc/nginx/sites-available/panel /etc/nginx/sites-enabled/"
                ;;
            *)
                echo "  sudo cp $INSTALL_DIR/deploy/nginx_panel.conf /etc/nginx/conf.d/panel.conf"
                ;;
        esac
    else
        echo "  # Nginx config needs domain configuration"
        case "$PKG_MANAGER" in
            apt-get)
                echo "  sudo cp $INSTALL_DIR/deploy/nginx_game_chrisvanek.conf /etc/nginx/sites-available/panel"
                echo "  sudo ln -s /etc/nginx/sites-available/panel /etc/nginx/sites-enabled/"
                ;;
            *)
                echo "  sudo cp $INSTALL_DIR/deploy/nginx_game_chrisvanek.conf /etc/nginx/conf.d/panel.conf"
                ;;
        esac
    fi
    echo "  sudo nginx -t"
    echo "  sudo systemctl enable nginx"
    echo "  sudo systemctl restart nginx"
    echo
    echo "  # Setup SSL with Let's Encrypt (optional)"
    case "$PKG_MANAGER" in
        apt-get)
            echo "  sudo apt install certbot python3-certbot-nginx"
            ;;
        dnf|yum)
            echo "  sudo $PKG_MANAGER install certbot python3-certbot-nginx"
            ;;
        apk)
            echo "  sudo apk add certbot certbot-nginx"
            ;;
        pacman)
            echo "  sudo pacman -S certbot certbot-nginx"
            ;;
        brew)
            echo "  brew install certbot"
            ;;
    esac
    echo "  sudo certbot --nginx -d $DOMAIN"
    echo
    echo "  # Open firewall ports (if firewall is active)"
    echo "  sudo ufw allow 80/tcp   # HTTP"
    echo "  sudo ufw allow 443/tcp  # HTTPS"
    echo "  sudo ufw allow 8080/tcp # Panel (if not using nginx proxy)"
    echo
}
